/************************************************************

	Token_Data.cpp  -  generated by CodeGenerator r$Rev$

************************************************************/

#include "MSVCC.h"
#include "Token_Data.h"
#include "MainClass.h"
#include <sstream>

XERCES_CPP_NAMESPACE_USE
Token_Data::Token_Data() :
	Token(),
	n (""),
	s (0),
	l (0),
	d (false),
	ood (false),
	tL (0),
	gL (0)
{
		gT = DateTime();
}

Token_Data::Token_Data(const Token_Data& Data, bool copyTransition) : Token(Data, copyTransition)
	, n(Data.get_n()), s(Data.get_s()), l(Data.get_l()), gT(Data.get_gT()), d(Data.get_d()), ood(Data.get_ood()), tL(Data.get_tL()), gL(Data.get_gL()) {}

Token_Data::~Token_Data() {
}

Token_Data& Token_Data::operator= (const Token_Data& Data) {
	if (this == &Data) return *this; // self assignment?
	Token::operator=(Data);
	n = Data.get_n();
	s = Data.get_s();
	l = Data.get_l();
	gT = Data.get_gT();
	d = Data.get_d();
	ood = Data.get_ood();
	tL = Data.get_tL();
	gL = Data.get_gL();
	return *this;
}

const std::string Token_Data::content() const {
	static bool locked = false;
	std::ostringstream str;

	if (!locked) {
		locked = true;
		str << "{" << "n=\"" << n << "\"" << "; " << "s=" << s << "; " << "l=" << l << "; " << "gT=" << gT.toString() << "; " << "d=" << d << "; " << "ood=" << ood << "; " << "tL=" << tL << "; " << "gL=" << gL << "}";
		locked = false;
	} else {
		str << "NULL";
	}
	return str.str();
}

void Token_Data::createTokensFromDB(NetClass* net, GMDB* connection,token_info_list &tokens, token_reference_list &refs)
{
	token_description_list tokenlist;
	vector<attr_name_type_info*> attr_infos;

	attr_name_type_info *attr_info = new attr_name_type_info;
	attr_info->name="n";
	attr_info->sql_c_type = SQL_C_CHAR;
	attr_infos.push_back(attr_info);

	attr_info = new attr_name_type_info;
	attr_info->name="s";
	attr_info->sql_c_type = SQL_C_SLONG;
	attr_infos.push_back(attr_info);

	attr_info = new attr_name_type_info;
	attr_info->name="l";
	attr_info->sql_c_type = SQL_C_SLONG;
	attr_infos.push_back(attr_info);

	attr_info = new attr_name_type_info;
	attr_info->name="gT";
	attr_info->sql_c_type = SQL_C_TYPE_TIMESTAMP;
	attr_infos.push_back(attr_info);

	attr_info = new attr_name_type_info;
	attr_info->name="d";
	attr_info->sql_c_type = SQL_C_BIT;
	attr_infos.push_back(attr_info);

	attr_info = new attr_name_type_info;
	attr_info->name="ood";
	attr_info->sql_c_type = SQL_C_BIT;
	attr_infos.push_back(attr_info);

	attr_info = new attr_name_type_info;
	attr_info->name="tL";
	attr_info->sql_c_type = SQL_C_SLONG;
	attr_infos.push_back(attr_info);

	attr_info = new attr_name_type_info;
	attr_info->name="gL";
	attr_info->sql_c_type = SQL_C_SLONG;
	attr_infos.push_back(attr_info);

	connection->DBReadTokens(1,"Data",&attr_infos,&tokenlist);

	vector<attr_name_type_info*>::iterator atinf_it;
	for (atinf_it=attr_infos.begin(); atinf_it!=attr_infos.end(); atinf_it++)
		delete (*atinf_it);

	vector<token_description*>::iterator tok_it;
	for (tok_it=tokenlist.token_descriptions.begin();tok_it!=tokenlist.token_descriptions.end();tok_it++)
	{
		token_info *tinfo = new token_info;
		SMARTPTR(Token_Data) t = NEW_MACRO(Token_Data,Token_Data);

		tinfo->tokentypename = "Data";
		tinfo->token = t;
		tinfo->id = (*tok_it)->id;
		tinfo->place_name = (*tok_it)->place_name;
		tokens.push_back(tinfo);


		t->set_n(((char*)(&((*tok_it)->attributes[0]->value))));

		t->set_s(*((long*)(&((*tok_it)->attributes[1]->value))));

		t->set_l(*((long*)(&((*tok_it)->attributes[2]->value))));

		t->set_gT(*((DateTime*)(&((*tok_it)->attributes[3]->value))));

		t->set_d(*((bool*)(&((*tok_it)->attributes[4]->value))));

		t->set_ood(*((bool*)(&((*tok_it)->attributes[5]->value))));

		t->set_tL(*((long*)(&((*tok_it)->attributes[6]->value))));

		t->set_gL(*((long*)(&((*tok_it)->attributes[7]->value))));

		vector<token_attribute*>::iterator attr_it;
		for (attr_it=(*tok_it)->attributes.begin(); attr_it!=(*tok_it)->attributes.end();attr_it++)
			delete (*attr_it);
		delete (*tok_it);
	}
}

void Token_Data::addInitialTokens(Place *p) {
	try {
		XMLPlatformUtils::Initialize();
	}
	catch (const XMLException& toCatch) {
		char* message = XMLString::transcode(toCatch.getMessage());
		cout << "Error during initialization! :" << message << "\n";
		delete [] message;
		exit(1);
	}

	XercesDOMParser* parser = new XercesDOMParser();

	ErrorHandler* errHandler = (ErrorHandler*) new HandlerBase();
	parser->setErrorHandler(errHandler);

	try {
		parser->parse("marking.xml");
	}
	catch (const XMLException& toCatch) {
		char* message = XMLString::transcode(toCatch.getMessage());
		cout << "Xerces XML Exception message is: " << message << "\n";
		delete [] message;
		exit(1);
	}
	catch (const DOMException& toCatch) {
		char* message = XMLString::transcode(toCatch.msg);
		cout << "Xerces DOM Exception message is: " << message << "\n";
		delete [] message;
		exit(1);
	}
	catch (const SAXException& toCatch) {
		char* message = XMLString::transcode(toCatch.getMessage());
		cout << "Xerces SAX Exception message is: " << message << "\n";
		delete [] message;
		exit(1);
	}
	catch (...) {
		cout << "Xerces Unexpected Exception \n";
		exit(1);
	}

	XERCES_CPP_NAMESPACE_QUALIFIER DOMDocument* doc = parser->getDocument();
	DOMNodeList* tokenList = doc->getElementsByTagName(XMLString::transcode("token"));

	for (unsigned int i = 0; i < tokenList->getLength(); i++) {
		DOMElement* element = (DOMElement*)tokenList->item(i);
		string place = XMLString::transcode(element->getAttribute(XMLString::transcode("place")));

		if (place == p->getName()) {
			SMARTPTR(Token_Data) newToken = NEW_MACRO(Token_Data,Token_Data());
			newToken->readTokenData(tokenList->item(i));
			p->addToken(newToken);
		}
	}

	delete parser;
	delete errHandler;
}

void Token_Data::readTokenData(DOMNode* node) {
	DOMElement* element = (DOMElement*) node;

	//base attributes
	string attribute_n = XMLString::transcode(element->getAttribute(XMLString::transcode("n")));
	this->set_n(attribute_n);

	string attribute_s = XMLString::transcode(element->getAttribute(XMLString::transcode("s")));
	this->set_s(atol(attribute_s.c_str()));

	string attribute_l = XMLString::transcode(element->getAttribute(XMLString::transcode("l")));
	this->set_l(atol(attribute_l.c_str()));

	string attribute_gT = XMLString::transcode(element->getAttribute(XMLString::transcode("gT")));
	this->set_gT(DateTime(attribute_gT));

	string attribute_d = XMLString::transcode(element->getAttribute(XMLString::transcode("d")));
	if (attribute_d == "true")
		this->set_d(true);
	else
		this->set_d(false);

	string attribute_ood = XMLString::transcode(element->getAttribute(XMLString::transcode("ood")));
	if (attribute_ood == "true")
		this->set_ood(true);
	else
		this->set_ood(false);

	string attribute_tL = XMLString::transcode(element->getAttribute(XMLString::transcode("tL")));
	this->set_tL(atol(attribute_tL.c_str()));

	string attribute_gL = XMLString::transcode(element->getAttribute(XMLString::transcode("gL")));
	this->set_gL(atol(attribute_gL.c_str()));

}

string const& Token_Data::get_n() const {
	return this->n;
}

long Token_Data::get_s() const {
	return this->s;
}

long Token_Data::get_l() const {
	return this->l;
}

DateTime const& Token_Data::get_gT() const {
	return this->gT;
}

bool Token_Data::get_d() const {
	return this->d;
}

bool Token_Data::get_ood() const {
	return this->ood;
}

long Token_Data::get_tL() const {
	return this->tL;
}

long Token_Data::get_gL() const {
	return this->gL;
}

void Token_Data::set_n(const string &n){
	if (MainClass::getLog()->isTokenLogging())
		(*MainClass::getLog()->getTokenLog())<<"set : Data.n to "<<n<<endl;
	this->n = n;
}

void Token_Data::set_s(long s){
	if (MainClass::getLog()->isTokenLogging())
		(*MainClass::getLog()->getTokenLog())<<"set : Data.s to "<<s<<endl;
	this->s = s;
}

void Token_Data::set_l(long l){
	if (MainClass::getLog()->isTokenLogging())
		(*MainClass::getLog()->getTokenLog())<<"set : Data.l to "<<l<<endl;
	this->l = l;
}

void Token_Data::set_gT(const DateTime &gT){
	if (MainClass::getLog()->isTokenLogging())
		(*MainClass::getLog()->getTokenLog())<<"set : Data.gT to "<<gT.toString()<<endl;
	this->gT = gT;
}

void Token_Data::set_d(bool d){
	if (MainClass::getLog()->isTokenLogging())
		(*MainClass::getLog()->getTokenLog())<<"set : Data.d to "<<d<<endl;
	this->d = d;
}

void Token_Data::set_ood(bool ood){
	if (MainClass::getLog()->isTokenLogging())
		(*MainClass::getLog()->getTokenLog())<<"set : Data.ood to "<<ood<<endl;
	this->ood = ood;
}

void Token_Data::set_tL(long tL){
	if (MainClass::getLog()->isTokenLogging())
		(*MainClass::getLog()->getTokenLog())<<"set : Data.tL to "<<tL<<endl;
	this->tL = tL;
}

void Token_Data::set_gL(long gL){
	if (MainClass::getLog()->isTokenLogging())
		(*MainClass::getLog()->getTokenLog())<<"set : Data.gL to "<<gL<<endl;
	this->gL = gL;
}

