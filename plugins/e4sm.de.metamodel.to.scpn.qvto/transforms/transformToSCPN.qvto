import SCPNConstructors;
import SCPNHelpers;

modeltype e4sm "strict" uses e4sm("http://de.tu-ilmenau/e4sm/1.0.0");
modeltype scpn "strict" uses scpn("http://timenet.tu-ilmenau.de/schema/SCPN");


transformation transformToSCPN(in e:e4sm, out s:scpn);
configuration property packageName : String;

main() {
	log("\nTransforming E4SM Model to Stochastic Colored Petri Net");
	assert fatal (packageName <> null and not packageName->isEmpty() and packageName <> "") with log("Please set a package name in the run configuration.");
	
	var packages : Bag(Package) = e.rootObjects()[Model].packages->select(p:Package | p.name = packageName);
	assert fatal (packages->size() > 0) with log("Could not find any package named \"" + packageName + "\". Please check your Run Configurations.");
	
	packages->map packageToSCPN();
	log("Main: Transformation completed.");
}
	

/** Mappings **/
mapping Package::packageToSCPN() : SCPNNet{
	log("\nTransforming package " +  self.name);
	//Attributes
	id := safeString(self.name);
	
	//Defautl SCPN Configuration for TimeNET:
	gridActive := true;
	netclass := "SCPN";
	sharpEdges := false;
	
	//Children
	if(self.components->isEmpty()){
		log("\n=== Warning: no components to transform ===");
	}
	else {
		log("\n=== Transforming all Components ===");
		var res = self.components->map transformComponent();
		place += res.pl;
		immediateTransition += res.iTr;
		arc += res.arcs;
		timedTransition += res.tt;
	};
	
	if(self.sectors->isEmpty()){
		log("\n=== Info: No sectors to transform ===");
	}
	else {
		log("\n=== Transforming all Sectors ===");
		substitutionTransition += self.sectors->map transformSector();
	};
	
	//Transform connectors
	if(self.connectors->isEmpty()){
		log("\n=== Warning: no connectors to transform ===");
	}
	else{
		log("\n=== Transforming all Connectors ===");
		var connectors := self.connectors->map connectorToSCPN();
		arc += connectors.arcs;
		timedTransition += connectors.tt;
	};
}

mapping Connector::connectorToSCPN(): arcs:List(ArcType), tt:TimedTransitionType {
	init{
	    var name := self.computeName();
		log("\nTransforming connector " +  name);
	    assert fatal (name <> "Invalid connector") with log ("Invalid connector found. Please fix it or remove it from the model: " + self.toString());
		tt := new TimedTransitionType(self.computeName());
	}

	var arc1 := new ArcType(self.computeName() + "_1");
	var arc2 := new ArcType(self.computeName() + "_2");
	
	arc1.fromNode := self.source.resolveone(PlaceType).id;
	arc1.toNode := tt.id;
	
	arc2.fromNode := tt.id;
	arc2.toNode := self.target.resolveone(PlaceType).id;
	
	arcs->add(arc1);
	arcs->add(arc2);

	log("Transformed connector " +  name);
}

/**
  Converts an e4sm Queue to a Petri net place queue
*/
helper e4sm::QueueType::convertQueueType() : scpn::QueueType {
	switch {
	case  (self = e4sm::QueueType::RANDOM){
			return scpn::QueueType::Random;
		}
		case  (self = e4sm::QueueType::FIFO){
			return scpn::QueueType::FIFO;
		}
		case  (self = e4sm::QueueType::LIFO){
			return scpn::QueueType::LIFO;
		}
		else{
			log("Unsupported queue type " + self.toString());
			return scpn::QueueType::Random;
		}
	};
	//Not needed, but it removes the warning
	return scpn::QueueType::Random;
}

mapping Sector::transformSector() : SubstitutionTransitionType{
	var idName := safeString(self.name);
	log("\nTransforming sector " +  self.name);
	id := idName; //In TimeNET: 0.0, 0.1...
	
	//TimeNET's default:
	replication := 0;
    type:=scpn::Type::node;
	
	//If these are added, TimeNet says the network's schema is outdated.
	//serverType:=ServerTypeType::ExclusiveServer;
    //specType:=SpecTypeType::Automatic;
	//takeFirst:=false;
    //watch:=false;


 	graphics := object GraphicsType {
 		   orientation:=0;
 			x := 650;
	 		y := 200;
	 	};
	 	label := object LabelType{
	 	   id:=idName+"_label";
	 	   text:=self.name;
	 	   type:=scpn::Type::text;
	 	   graphics := object GraphicsType {
			x := -10;
	 		y := -40;
	 	   };
	 	};
    net += object ReplicationType{
    	gridActive := true;
    	netclass:="SCPN";
    	sharpEdges := false;
    	id:=idName+"_subnet";
    };    
}

mapping InputPin::transform(parentName:String, index: Integer) : PlaceType {
init{
 	result:= new PlaceType(parentName +"_in_"+index.toString());
}
}

mapping OutputPin::transform(parentName:String, index: Integer) : PlaceType {
init{
 	result:= new PlaceType(parentName +"_out_"+index.toString());
}
}

mapping Component::transformComponent() : pl: List(PlaceType), iTr : List(ImmediateTransitionType), arcs : List (ArcType), tt : List(TimedTransitionType) {		
	init{
		log("\nTransforming component " +  self.name);
		//pl := List{};
		//iTr := List{};
		
		var res := self.components->map transformComponent();
		pl += res.pl;
		iTr += res.iTr;
		arcs += res.arcs;
		tt += res.tt;
		
		var componentMainPlace := new PlaceType(self.name + "_main");
		pl->add(componentMainPlace);
		
		var componentReadyTransition := new ImmediateTransitionType(self.name + "_ready");
		iTr->add(componentReadyTransition);
		
		var readyToMain := new ArcType(self.name+"_ready_to_main");
		readyToMain.fromNode := componentReadyTransition.id;
		readyToMain.toNode := componentMainPlace.id;
		arcs->add(readyToMain);
		
		// Timed transition for the component execution
		var timedTran = new TimedTransitionType(self.name+"_execution");
		tt->add(timedTran);
		
		// Arc between the main Place and the timed transition
		var mainToTimed := new ArcType(self.name+"_main_to_timed");
		mainToTimed.fromNode := componentMainPlace.id;
		mainToTimed.toNode := timedTran.id;
		arcs->add(mainToTimed);

		
		// Transform the input pins
		var i:Integer := 0;
		self.pins[InputPin]->forEach(ip) {
		    //Create the place
		    var inputPinPlace := ip.map transform(self.name, i);
		    pl->add(inputPinPlace);
			
			//Create an arc to connect it to the component
			var arcToTransition = new ArcType(inputPinPlace.id + "_to_" + self.name);
			arcToTransition.fromNode := inputPinPlace.id;
			arcToTransition.toNode := componentReadyTransition.id;
			arcs->add(arcToTransition);
			
			i := i+1;
		};
		
		i := 0;
		self.pins[OutputPin]->forEach(op) {
			//Create the place
		    var outputPinPlace := op.map transform(self.name, i);
		    pl->add(outputPinPlace);
			
			//Create an arc to connect the the component to the place
			var arcFromTransition = new ArcType(outputPinPlace.id + "_from_" + self.name);
			arcFromTransition.fromNode := timedTran.id;
			arcFromTransition.toNode := outputPinPlace.id;
			arcs->add(arcFromTransition);
			
			i := i+1;
		};
		
	 }
	 log("Transformed component '" +  self.name + "' to " + pl->size().toString()+ " places and "
	  + iTr->size().toString() + " immediate transition(s)");
}