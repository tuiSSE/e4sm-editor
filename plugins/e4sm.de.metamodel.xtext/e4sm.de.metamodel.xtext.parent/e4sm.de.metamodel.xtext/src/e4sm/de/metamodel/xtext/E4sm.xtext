// automatically generated by Xtext
grammar e4sm.de.metamodel.xtext.E4sm with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://de.tu-ilmenau/e4sm/core/1.0.0" as core
import "http://de.tu-ilmenau/e4sm/1.0.0"
import "http://de.tu-ilmenau/e4sm/analysis/1.0.0" as analysis
import "http://de.tu-ilmenau/e4sm/execution/1.0.0" as execution
import "http://de.tu-ilmenau/e4sm/security/1.0.0" as security

Model returns Model:
	'model'
	Name
	'{'
	Documentation?
	(imports+=Import ("," imports+=Import)*)?
	(securityThreatsImport+=SecurityThreatsImport ("," securityThreatsImport+=SecurityThreatsImport)*)?
	(securityThreatsDefinition=KnownSecurityThreats)?
	(securitySpecification=SecuritySpecification)?
	('picturesPath' PROPERTY_ASSIGN personsPicturesPath=EString)?
	(types+=TypeSpecification ("," types+=TypeSpecification)*)?
	Parameters?
	(packages+=Package ("," packages+=Package)*)?
	(actors+=Actor ("," actors+=Actor)*)?
	(variants+=Variant ("," variants+=Variant)*)?
	(classificationClasses+=ClassificationClass ("," classificationClasses+=ClassificationClass)*)?
	(environments+=Environment ("," environments+=Environment)*)?
	'}';

fragment Documentation returns core::DocumentableElement:
	'doc' PROPERTY_ASSIGN documentation=EString;
	
fragment Parameters returns analysis::ParameterizableElement:
	'parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}'
;

fragment Name returns core::NamedElement:
	name=EString
;

fragment EcoreName returns ecore::ENamedElement:
	name=EString
;

ClassificationClass returns ClassificationClass:
	{ClassificationClass}
	'cl' Name;

ClassificationClassDistribution returns ClassificationClassDistribution:
	{ClassificationClassDistribution}
	((not?='not')? classificationClass=[ClassificationClass|EString] probability=EDouble);

Environment returns Environment:
	{Environment}
	'environment' Name
	'{'
	(classificationClasses+=ClassificationClassDistribution ("," classificationClasses+=ClassificationClassDistribution)
	*)?
	(',' 'OOD' oodProbability=EDouble)?
	'}';

ConfusionMatrix returns ConfusionMatrix:
	BinaryConfusionMatrix | MulticlassConfusionMatrix;

BinaryConfusionMatrix returns BinaryConfusionMatrix:
	{BinaryConfusionMatrix}
	'confusion' 'matrix' Name
	'+' positiveClass=[ClassificationClass|EString]
	'{'
	'TP' PROPERTY_ASSIGN tp=EInt ',' 'FN' PROPERTY_ASSIGN fn=EInt
	',' 'FP' PROPERTY_ASSIGN fp=EInt ',' 'TN' PROPERTY_ASSIGN tn=EInt
	'}';

MulticlassConfusionMatrix returns MulticlassConfusionMatrix:
	{MulticlassConfusionMatrix}
	'confusion' 'matrix' Name
	'{'
	(entries+=ConfusionMatrixEntry ("," entries+=ConfusionMatrixEntry)*)?
	'}';

ConfusionMatrixEntry returns ConfusionMatrixEntry:
	{ConfusionMatrixEntry}
	truth=[ClassificationClass|EString] predicted=[ClassificationClass|EString] PROPERTY_ASSIGN value=EInt;

// ~~~~~~~~    SECURITY   ~~~~~~~~ //
SecurityThreatsImport returns SecurityThreatsImport:
	{SecurityThreatsImport}
	'import' 'security' securityThreat=[security::KnownSecurityThreats] ';';

KnownSecurityThreats returns security::KnownSecurityThreats:
	{security::KnownSecurityThreats}
	'knownSecurityThreats'
	'{'
	(cves+=CVE (cves+=CVE)*)?
	// TODO CWE
	'}';

CVE returns security::CVE:
	{security::CVE}
	'cve' cveId=EString
	('cvss' PROPERTY_ASSIGN cvss=EDouble)?
	(vectorString=EString)?
	('descr' PROPERTY_ASSIGN description=EString)?
	('affects' '{'
	affectsComponents+=[Component|EString] (',' affectsComponents+=[Component|EString])*
	'}')?';';

SecuritySpecification returns security::SecuritySpecification:
	{security::SecuritySpecification}
	'securitySpec' '{'
	(assetDefinitions+=AssetDefinition (assetDefinitions+=AssetDefinition)*)?
	(attackSurfaces+=AttackSurface (attackSurfaces+=AttackSurface)*)?
	'}';

AssetDefinition returns security::AssetDefinition:
	{security::AssetDefinition}
	'asset' component=[Component|EString] ';';

AttackSurface returns security::AttackSurface:
	{security::AttackSurface}
	'attack' 'surface' component=[Component|EString] ';';

// ^^^^^^^^^^  SECURITY   ^^^^^^^^^^ //
Import returns Import:
	{Import}
	'import' referencedModel=[Model|STRING] ';';

Actor returns Actor:
	Actor_Impl | Human_Impl | Robot | Person;

ValueSpecification returns core::ValueSpecification:
	LiteralNull | LiteralString | LiteralInteger | LiteralBoolean | LiteralFloat | LiteralDouble | LiteralLong |
	LiteralShort | LiteralByte | LiteralCharacter | LiteralDate;

Component returns Component:
	Component_Impl | MachineLearningComponent | ClassificationComponent | PhysicalComponent_Impl |
	SoftwareComponent_Impl | Heuristic | Function |
	ExternalDependency | Sensor | Actuator;

ClassificationComponent returns ClassificationComponent:
	BinaryClassificationComponent | MulticlassClassificationComponent;

Connector returns Connector:
	Connector_Impl | PhysicalConnector | LogicalConnector;

EDataType returns ecore::EDataType:
	EDataType_Impl | EEnum;

EStructuralFeature returns ecore::EStructuralFeature:
	EAttribute | EReference;

EClassifier returns ecore::EClassifier:
	EClass | EDataType_Impl | EEnum;

DataStore returns DataStore:
	{DataStore}
	'datastore'
	(type=[core::TypeSpecification])?
	Name // (':' type = [ecore::EDataType|EString])?
	('{'
	Documentation?
	Parameters?
	'}')?;

DataNode returns DataNode:
	Pin | DataStore;

Pin returns Pin:
	InputPin | OutputPin;

EString returns ecore::EString:
	STRING | ID;

Parameter returns analysis::Parameter:
	{analysis::Parameter}
	'par' Name (':=' initialValue=ValueSpecification)?
	('{'
	Documentation?
	('parameterDefinition' PROPERTY_ASSIGN parameterDefinition=[analysis::ParameterDefinition|EString])?
	('appliesOnlyOnVariants' '(' appliesOnlyOnVariants+=[core::Variant|EString] (","
	appliesOnlyOnVariants+=[core::Variant|EString])* ')')?
	('doesNotApplyOnVariants' '(' doesNotApplyOnVariants+=[core::Variant|EString] (","
	doesNotApplyOnVariants+=[core::Variant|EString])* ')')?
	('currentValue' PROPERTY_ASSIGN currentValue=ValueSpecification)?
	'}')?;

Package returns Package:
	'package'
	Name
	'{'
	Documentation?
	('simulationDuration' PROPERTY_ASSIGN simulationDuration=EInt)?
	('mainResponsible' PROPERTY_ASSIGN mainResponsible=[Person|EString])?
	('specifiesComponent' PROPERTY_ASSIGN specifiesComponent=[Component|EString])?
	('processingUnits' PROPERTY_ASSIGN processingUnits=EInt)?
	Parameters?
	(components+=Component ("," components+=Component)*)?
	(connectors+=Connector ("," connectors+=Connector)*)?
	(datastores+=DataStore ("," datastores+=DataStore)*)?
	(sectors+=Sector ("," sectors+=Sector)*)?
	('subPackages' '{' packages+=Package ("," packages+=Package)* '}')?
	'}';

terminal PROPERTY_ASSIGN:
	':';

Actor_Impl returns Actor:
	{Actor}
	'actor'
	Name
	('{'
	Documentation?
	'}')?;

Variant returns core::Variant:
	{core::Variant}
	'variant'
	Name
	('{'
	Documentation?
	'}')?;

ParameterDefinition returns analysis::ParameterDefinition:
	{analysis::ParameterDefinition}
	'ParameterDefinition'
	Name
	'{'
	Documentation?
	('unit' unit=UnitOfMeasurement)?
	// ('type' type = [ecore::EDataType|EString])?
	('parameters' '(' parameters+=[analysis::Parameter|EString] ("," parameters+=[analysis::Parameter|EString])* ')')?
	// ('mustBeDefinedOn' '(' mustBeDefinedOn += [ecore::EClass|EString] ( "," mustBeDefinedOn += [ecore::EClass|EString])* ')' )?
	// ('canBeDefinedOn' '(' canBeDefinedOn += [ecore::EClass|EString] ( "," canBeDefinedOn += [ecore::EClass|EString])* ')' )?
	// ('shallNotBeDefinedOn' '(' shallNotBeDefinedOn += [ecore::EClass|EString] ( "," shallNotBeDefinedOn += [ecore::EClass|EString])* ')' )?
	('defaultValue' defaultValue=ValueSpecification)?
	'}';

EDataType_Impl returns ecore::EDataType:
	{ecore::EDataType}
	'EDataType'
	EcoreName
	'{'
	('instanceClassName' instanceClassName=EString)?
	('instanceTypeName' instanceTypeName=EString)?
	('serializable' serializable=EBoolean)?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eTypeParameters' '{' eTypeParameters+=ETypeParameter ("," eTypeParameters+=ETypeParameter)* '}')?
	'}';

enum UnitOfMeasurement returns core::UnitOfMeasurement:
	cm='cm' | m='m' | mm='mm' | percentage='percentage' | s='s' | ms='ms' | minutes='minutes' | hours='hours' |
	mbps='mbps' | none='none';

EClass returns ecore::EClass:
	{ecore::EClass}
	(abstract?='abstract')?
	(interface?='interface')?
	'EClass'
	EcoreName
	'{'
	('instanceClassName' instanceClassName=EString)?
	('instanceTypeName' instanceTypeName=EString)?
	('eSuperTypes' '(' eSuperTypes+=[ecore::EClass|EString] ("," eSuperTypes+=[ecore::EClass|EString])* ')')?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eTypeParameters' '{' eTypeParameters+=ETypeParameter ("," eTypeParameters+=ETypeParameter)* '}')?
	('eOperations' '{' eOperations+=EOperation ("," eOperations+=EOperation)* '}')?
	('eStructuralFeatures' '{' eStructuralFeatures+=EStructuralFeature ("," eStructuralFeatures+=EStructuralFeature)*
	'}')?
	('eGenericSuperTypes' '{' eGenericSuperTypes+=EGenericType ("," eGenericSuperTypes+=EGenericType)* '}')?
	'}';

EAnnotation returns ecore::EAnnotation:
	{ecore::EAnnotation}
	'EAnnotation'
	'{'
	('source' source=EString)?
	('references' '(' references+=[ecore::EObject|EString] ("," references+=[ecore::EObject|EString])* ')')?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('details' '{' details+=EStringToStringMapEntry ("," details+=EStringToStringMapEntry)* '}')?
	('contents' '{' contents+=EObject ("," contents+=EObject)* '}')?
	'}';

ETypeParameter returns ecore::ETypeParameter:
	{ecore::ETypeParameter}
	'ETypeParameter'
	EcoreName
	'{'
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eBounds' '{' eBounds+=EGenericType ("," eBounds+=EGenericType)* '}')?
	'}';

EBoolean returns ecore::EBoolean:
	'true' | 'false';

EEnum returns ecore::EEnum:
	{ecore::EEnum}
	'EEnum'
	EcoreName
	'{'
	('instanceClassName' instanceClassName=EString)?
	('instanceTypeName' instanceTypeName=EString)?
	('serializable' serializable=EBoolean)?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eTypeParameters' '{' eTypeParameters+=ETypeParameter ("," eTypeParameters+=ETypeParameter)* '}')?
	('eLiterals' '{' eLiterals+=EEnumLiteral ("," eLiterals+=EEnumLiteral)* '}')?
	'}';

EStringToStringMapEntry returns ecore::EStringToStringMapEntry:
	{ecore::EStringToStringMapEntry}
	'EStringToStringMapEntry'
	'{'
	('key' key=EString)?
	('value' value=EString)?
	'}';

EObject returns ecore::EObject:
	{ecore::EObject}
	'EObject';

EGenericType returns ecore::EGenericType:
	{ecore::EGenericType}
	'EGenericType'
	'{'
	('eTypeParameter' eTypeParameter=[ecore::ETypeParameter|EString])?
	('eClassifier' eClassifier=[ecore::EClassifier|EString])?
	('eUpperBound' eUpperBound=EGenericType)?
	('eTypeArguments' '{' eTypeArguments+=EGenericType ("," eTypeArguments+=EGenericType)* '}')?
	('eLowerBound' eLowerBound=EGenericType)?
	'}';

EEnumLiteral returns ecore::EEnumLiteral:
	{ecore::EEnumLiteral}
	'EEnumLiteral'
	EcoreName
	'{'
	('value' value=EInt)?
	('literal' literal=EString)?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	'}';

EOperation returns ecore::EOperation:
	{ecore::EOperation}
	'EOperation'
	EcoreName
	'{'
	('ordered' ordered=EBoolean)?
	('unique' unique=EBoolean)?
	('lowerBound' lowerBound=EInt)?
	('upperBound' upperBound=EInt)?
	('eType' eType=[ecore::EClassifier|EString])?
	('eExceptions' '(' eExceptions+=[ecore::EClassifier|EString] ("," eExceptions+=[ecore::EClassifier|EString])* ')')?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eGenericType' eGenericType=EGenericType)?
	('eTypeParameters' '{' eTypeParameters+=ETypeParameter ("," eTypeParameters+=ETypeParameter)* '}')?
	('eParameters' '{' eParameters+=EParameter ("," eParameters+=EParameter)* '}')?
	('eGenericExceptions' '{' eGenericExceptions+=EGenericType ("," eGenericExceptions+=EGenericType)* '}')?
	'}';

EParameter returns ecore::EParameter:
	{ecore::EParameter}
	'EParameter'
	EcoreName
	'{'
	('ordered' ordered=EBoolean)?
	('unique' unique=EBoolean)?
	('lowerBound' lowerBound=EInt)?
	('upperBound' upperBound=EInt)?
	('eType' eType=[ecore::EClassifier|EString])?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eGenericType' eGenericType=EGenericType)?
	'}';

EAttribute returns ecore::EAttribute:
	{ecore::EAttribute}
	(volatile?='volatile')?
	(transient?='transient')?
	(unsettable?='unsettable')?
	(derived?='derived')?
	(iD?='iD')?
	'EAttribute'
	EcoreName
	'{'
	('ordered' ordered=EBoolean)?
	('unique' unique=EBoolean)?
	('lowerBound' lowerBound=EInt)?
	('upperBound' upperBound=EInt)?
	('changeable' changeable=EBoolean)?
	('defaultValueLiteral' defaultValueLiteral=EString)?
	('eType' eType=[ecore::EClassifier|EString])?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eGenericType' eGenericType=EGenericType)?
	'}';

EReference returns ecore::EReference:
	{ecore::EReference}
	(volatile?='volatile')?
	(transient?='transient')?
	(unsettable?='unsettable')?
	(derived?='derived')?
	(containment?='containment')?
	'EReference'
	EcoreName
	'{'
	('ordered' ordered=EBoolean)?
	('unique' unique=EBoolean)?
	('lowerBound' lowerBound=EInt)?
	('upperBound' upperBound=EInt)?
	('changeable' changeable=EBoolean)?
	('defaultValueLiteral' defaultValueLiteral=EString)?
	('resolveProxies' resolveProxies=EBoolean)?
	('eType' eType=[ecore::EClassifier|EString])?
	('eOpposite' eOpposite=[ecore::EReference|EString])?
	('eKeys' '(' eKeys+=[ecore::EAttribute|EString] ("," eKeys+=[ecore::EAttribute|EString])* ')')?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eGenericType' eGenericType=EGenericType)?
	'}';

LiteralNull returns core::LiteralNull:
	{core::LiteralNull}
	'null';

LiteralString returns core::LiteralString:
	{core::LiteralString}
	value=STRING;

LiteralBoolean returns core::LiteralBoolean:
	{core::LiteralBoolean}
	(value?='true' | 'false');

LiteralFloat returns core::LiteralFloat:
	{core::LiteralFloat}
	value=Float;

LiteralDouble returns core::LiteralDouble:
	{core::LiteralDouble}
	value=EDouble;

LiteralLong returns core::LiteralLong:
	{core::LiteralLong}
	value=Long;

LiteralShort returns core::LiteralShort:
	{core::LiteralShort}
	'LiteralShort'
	Name
	'{'
	('value' value=Short)?
	// ('type' type = [ecore::EDataType|EString])?
	'}';

LiteralByte returns core::LiteralByte:
	{core::LiteralByte}
	'LiteralByte'
	Name
	'{'
	('value' value=Byte)?
	// ('type' type = [ecore::EDataType|EString])?
	'}';

LiteralCharacter returns core::LiteralCharacter:
	{core::LiteralCharacter}
	'LiteralCharacter'
	Name
	'{'
	('value' value=Character)?
	// ('type' type = [ecore::EDataType|EString])?
	'}';

LiteralDate returns core::LiteralDate:
	{core::LiteralDate}
	'LiteralDate'
	Name
	'{'
	('value' value=Date)?
	// ('type' type = [ecore::EDataType|EString])?
	'}';

Float returns core::Float:
	'f' INT '.' INT;

Long returns core::Long:
	'l' INT;

// 'Long' /* TODO: implement this rule and an appropriate IValueConverter */ ;
Short returns core::Short:
	'Short' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Byte returns core::Byte:
	'Byte' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Character returns core::Character:
	'Character' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Date returns core::Date:
	'Date' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Component_Impl returns Component:
	{Component}
	'component'
	Name
	'{'
	Documentation?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	Parameters?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

Connector_Impl returns Connector:
	'connector'
	Name
	(source=[Pin|EString])? '->' (target=[Pin|EString])?
	('{'
	Documentation?
	('takes' timeFunction=ComplexTimefunction)?
	Parameters?
	'}')?;

Sector returns Sector:
	{Sector}
	'sector'
	Name
	'{'
	Documentation?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('sectors' '{' sectors+=Sector ("," sectors+=Sector)* '}')?
	'}';

Person returns Person:
	'person'
	(Name | surname=EString ',' Name)
	'{'
	Documentation?
	('department' department=EString)?
	('pictureFileName' pictureFileName=EString)?
	// ('responsibleForComponents' '(' responsibleForComponents += [Component|EString] (","
	// responsibleForComponents += [Component|EString])* ')')?
	'}';

MulticlassClassificationComponent returns MulticlassClassificationComponent:
	{MulticlassClassificationComponent}
	'multiclassClassificationComponent'
	Name
	'{'
	Documentation?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	Parameters?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	('confusionMatrixes' '{' confusionMatrixes+=MulticlassConfusionMatrix (","
	confusionMatrixes+=MulticlassConfusionMatrix)* '}')?
	'}';

BinaryClassificationComponent returns BinaryClassificationComponent:
	{BinaryClassificationComponent}
	'binaryClassificationComponent'
	Name
	'{'
	Documentation?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	Parameters?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	('confusionMatrixes' '{' confusionMatrixes+=BinaryConfusionMatrix ("," confusionMatrixes+=BinaryConfusionMatrix)*
	'}')?
	'}';

MachineLearningComponent returns MachineLearningComponent:
	{MachineLearningComponent}
	'mlComponent'
	Name
	'{'
	Documentation?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	Parameters?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

PhysicalComponent_Impl returns PhysicalComponent:
	{PhysicalComponent}
	'physicalComponent'
	Name
	'{'
	Documentation?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	Parameters?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

SoftwareComponent_Impl returns SoftwareComponent:
	{SoftwareComponent}
	'softwareComponent'
	Name
	'{'
	Documentation?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	Parameters?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

Heuristic returns Heuristic:
	{Heuristic}
	'heuristic'
	Name
	'{'
	Documentation?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	Parameters?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

Function returns Function:
	{Function}
	'function'
	Name
	'{'
	Documentation?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	Parameters?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

ExternalDependency returns ExternalDependency:
	{ExternalDependency}
	'externalDependency'
	Name
	'{'
	Documentation?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	Parameters?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

Sensor returns Sensor:
	'sensor'
	Name
	'{'
	Documentation?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	// 'timeFunction' timeFunction=TimeFunction
	('generates' classificationClasses+=[ClassificationClass|EString] (','
	classificationClasses+=[ClassificationClass|EString])*)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	Parameters?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

Actuator returns Actuator:
	{Actuator}
	'actuator'
	Name
	'{'
	Documentation?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	Parameters?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

enum RaceSemantic returns RaceSemantic:
	FCFS='FCFS' | DUPLICATE='DUPLICATE' | MERGE='MERGE' | MERGE_AND_DUPLICATE='MERGE_AND_DUPLICATE';

enum ComponentFiringStrategy returns ComponentFiringStrategy:
	AND='AND' | AND='&&' | OR='OR' | OR='||';

InputPin returns InputPin:
	{InputPin}
	(optional?='optional')? 'in' (stream?='stream')?
	(type=[core::TypeSpecification])?
	Name // (':' type = [ecore::EDataType|EString])?
	('{'
	Documentation?
	('collects' collect=EInt)?
	('raceSemantic' raceSemantic=RaceSemantic)?
	('queueType' queueType=QueueType)?
	// ('outgoingConnectors' '(' outgoingConnectors += [Connector|EString] ( "," outgoingConnectors += [Connector|EString])* ')' )?
	// ('incomingConnectors' '(' incomingConnectors += [Connector|EString] ( "," incomingConnectors += [Connector|EString])* ')' )?
	Parameters?
	'}')?;

OutputPin returns OutputPin:
	{OutputPin}
	'out' (stream?='stream')?
	(type=[core::TypeSpecification])?
	Name // (':' type = [ecore::EDataType])?
	('{'
	Documentation?
	('amplifies' amplify=EInt)?
	('outputUncertainty' outputUncertainty=EDouble)?
	('raceSemantic' raceSemantic=RaceSemantic)?
	('generates' tokenSpecification=TokenSpecification)?
	// ('outgoingConnectors' '(' outgoingConnectors += [Connector|EString] ( "," outgoingConnectors += [Connector|EString])* ')' )?
	// ('incomingConnectors' '(' incomingConnectors += [Connector|EString] ( "," incomingConnectors += [Connector|EString])* ')' )?
	Parameters?
	'}')? ('=' outputExpression=Expression)?;

enum QueueType returns QueueType:
	FIFO='FIFO' | LIFO='LIFO' | RANDOM='RANDOM' | LATEST_ONLY='LATEST_ONLY' | STORE='STORE';

EDouble returns ecore::EDouble:
	DOUBLE;

terminal DOUBLE returns ecore::EDouble:
	'-'? INT? '.' INT (('E' | 'e') '-'? INT)?;

EInt returns ecore::EInt:
	NEGATIVE_INT|INT;

terminal NEGATIVE_INT returns ecore::EInt:
	'-' INT;

TokenSpecification returns TokenSpecification:
	{TokenSpecification}
	inputSize+=Set;

Set returns Set:
	{Set}
	'set' '{' values+=SetValue (values+=SetValue)* '}';

SetValue returns SetValue:
	{SetValue}
	'value' PROPERTY_ASSIGN value=EString ('prob' PROPERTY_ASSIGN probability=EDouble & ('size' PROPERTY_ASSIGN
	size=EDouble)?) ';';

PhysicalConnector returns PhysicalConnector:
	'physicalConnector'
	Name
	(source=[Pin|EString])? '->' (target=[Pin|EString])?
	('{'
	Documentation?
	('minSpeed' minSpeed=Connectionspeed)?
	('maxSpeed' maxSpeed=Connectionspeed)?
	('takes' timeFunction=ComplexTimefunction)?
	Parameters?
	'}')?;

LogicalConnector returns LogicalConnector:
	'logicalConnector'
	Name
	(source=[Pin|EString])? '->' (target=[Pin|EString])?
	('{'
	Documentation?
	('takes' timeFunction=ComplexTimefunction)?
	Parameters?
	'}')?;

Connectionspeed returns Connectionspeed:
	'Connectionspeed' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Human_Impl returns Human:
	{Human}
	'human' Name
	('{'
	Documentation?
	'}')?;

Robot returns Robot:
	{Robot}
	'robot' Name
	('{'
	Documentation?
	'}')?;

/* EXECUTION */
Execution returns execution::Execution:
	{execution::Execution}
	elements+=Elements+;

Elements returns execution::ExecutionElement:
	Flow | ConnectableNode | Addition | ReferenceableItem | Assignment;

ConnectableNode returns execution::ConnectableNode:
	FlowFinal | ForkNode | MergeNode // TODO
;

Flow returns execution::Flow:
	source=[execution::ConnectableNode] '->' target=[execution::ConnectableNode] ('takes'
	timeFunction=ComplexTimefunction)?';';

ComplexTimefunction returns execution::TimeFunction: //TODO, allow operations
	ExeTimeFunction;

ExeTimeFunction returns execution::TimeFunction:
	{execution::TimeFunction}
	// TODO: this should also be able to accept integer values.
	// Placing EDouble|EInt here makes XText stop working
	function=TimeFunctions '(' par1=Expression (',' par2=Expression)? ')';

enum TimeFunctions returns execution::TimeFunctions:
	Det='Det' | Exp='Exp' | Uni='Uni' | DUni='DUni' | Norm='Norm' | LogNorm='LogNorm' | Wei='Wei' | DUni='Triang';

FlowFinal returns execution::FlowFinal:
	{execution::FlowFinal}
	source=[execution::ConnectableNode] '->' 'discard' ';';

ForkNode returns execution::ForkNode:
	'fork' source=[execution::ConnectableNode] '{'
	targets+=[execution::ConnectableNode] ("," targets+=[execution::ConnectableNode])*
	('takes' timeFunction=ComplexTimefunction)?
	'}';

MergeNode returns execution::MergeNode:
	'join' '{'
	sources+=[execution::ConnectableNode] ("," sources+=[execution::ConnectableNode])*
	('takes' timeFunction=ComplexTimefunction)?
	'}' 'to' target=[execution::ConnectableNode];

Expression returns execution::Expression:
	Addition;

Addition returns execution::Expression:
	{execution::Addition}
	left=Multiplication ({execution::Addition.left=current}
	(addition?='+' | subtraction?='-')
	right=Multiplication)*;

Multiplication returns execution::Expression:
	{execution::Multiplication}
	left=Exponentiation ({execution::Multiplication.left=current}
	(multiplication?='*' | division?='/')
	right=Exponentiation)*;

Exponentiation returns execution::Exponentiation:
	{execution::Exponentiation}
	left=Primary ({execution::Exponentiation.left=current}
	'^'
	right=(LiteralInteger | LiteralBoolean | LiteralFloat | LiteralDouble | LiteralLong | LiteralShort | LiteralByte))*;

AssignableElement returns execution::AssignableElement:
	Variable | OutputPin;

Primary returns execution::Expression:
	ParameterReference | ValueSpecification | VariableRef | InputPinAttributeReference | InputPinReference |
	'(' Addition ')';

LiteralInteger returns core::LiteralInteger:
	value=EInt;

ReferenceableItem returns execution::ReferenceableItem:
	Variable | Const;

ParameterReference returns execution::ParameterReference:
	{execution::ParameterReference}
	'@' parameter=[analysis::Parameter];

InputPinReference returns execution::InputPinReference:
	{execution::InputPinReference}
	'$' inputPin=[InputPin];

InputPinAttributeReference returns execution::InputPinAttributeReference:
	{execution::InputPinAttributeReference}
	'$' inputPin=[InputPin] '.' attribute=[core::AttributeSpecification];

Variable returns execution::Variable:
	'var' name=ID ('=' expression=Expression)? ';';

Const returns execution::Const:
	'const' name=ID ('=' expression=Expression)? ';';

Assignment returns execution::Assignment:
	target=AssignableElementReference '=' expression=Expression ';';

AssignableElementReference returns execution::AssignableElementReference:
	ref=[execution::AssignableElement];

VariableRef returns execution::VariableRef:
	{execution::VariableRef}
	variable=[execution::ReferenceableItem];

/* TYPES */
TypeSpecification returns core::TypeSpecification:
	{core::TypeSpecification}
	(abstract?='abstract')? 'type' name=ID ('extends' superType=[core::TypeSpecification])? '{'
	(attributes+=AttributeSpecification (',' attributes+=AttributeSpecification)*)?'}';

AttributeSpecification returns core::AttributeSpecification:
	IntegerAttribute | DoubleAttribute | StringAttribute | BooleanAttribute | ClassAttribute;

IntegerAttribute returns core::IntegerAttribute:
	{core::IntegerAttribute}
	'int' (array?='[' ']')? name=ID ('=' defaultValue=EInt)?;

DoubleAttribute returns core::DoubleAttribute:
	{core::DoubleAttribute}
	'double' (array?='[' ']')? name=ID ('=' defaultValue=EDouble)?;

StringAttribute returns core::StringAttribute:
	{core::StringAttribute}
	'string' (array?='[' ']')? name=ID ('=' defaultValue=EString)?;

BooleanAttribute returns core::BooleanAttribute:
	{core::BooleanAttribute}
	'boolean' (array?='[' ']')? name=ID ('=' defaultValue=EBoolean)?;

ClassAttribute returns core::ClassAttribute:
	{core::ClassAttribute}
	type=[core::TypeSpecification] (array?='[' ']')? name=ID;