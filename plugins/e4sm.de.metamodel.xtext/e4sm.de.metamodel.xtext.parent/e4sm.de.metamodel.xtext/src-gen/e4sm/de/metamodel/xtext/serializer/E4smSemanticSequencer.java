/*
 * generated by Xtext 2.30.0
 */
package e4sm.de.metamodel.xtext.serializer;

import com.google.inject.Inject;
import e4sm.de.metamodel.e4sm.Actor;
import e4sm.de.metamodel.e4sm.Actuator;
import e4sm.de.metamodel.e4sm.BinaryClassificationComponent;
import e4sm.de.metamodel.e4sm.BinaryConfusionMatrix;
import e4sm.de.metamodel.e4sm.ClassificationClass;
import e4sm.de.metamodel.e4sm.ClassificationClassDistribution;
import e4sm.de.metamodel.e4sm.Component;
import e4sm.de.metamodel.e4sm.ConfusionMatrixEntry;
import e4sm.de.metamodel.e4sm.Connector;
import e4sm.de.metamodel.e4sm.DataStore;
import e4sm.de.metamodel.e4sm.Environment;
import e4sm.de.metamodel.e4sm.ExternalDependency;
import e4sm.de.metamodel.e4sm.Function;
import e4sm.de.metamodel.e4sm.Heuristic;
import e4sm.de.metamodel.e4sm.Human;
import e4sm.de.metamodel.e4sm.Import;
import e4sm.de.metamodel.e4sm.InputPin;
import e4sm.de.metamodel.e4sm.LogicalConnector;
import e4sm.de.metamodel.e4sm.MachineLearningComponent;
import e4sm.de.metamodel.e4sm.Model;
import e4sm.de.metamodel.e4sm.MulticlassClassificationComponent;
import e4sm.de.metamodel.e4sm.MulticlassConfusionMatrix;
import e4sm.de.metamodel.e4sm.OutputPin;
import e4sm.de.metamodel.e4sm.Person;
import e4sm.de.metamodel.e4sm.PhysicalComponent;
import e4sm.de.metamodel.e4sm.PhysicalConnector;
import e4sm.de.metamodel.e4sm.Robot;
import e4sm.de.metamodel.e4sm.Sector;
import e4sm.de.metamodel.e4sm.Sensor;
import e4sm.de.metamodel.e4sm.SoftwareComponent;
import e4sm.de.metamodel.e4sm.analysis.AnalysisPackage;
import e4sm.de.metamodel.e4sm.analysis.ParameterDefinition;
import e4sm.de.metamodel.e4sm.core.BooleanAttribute;
import e4sm.de.metamodel.e4sm.core.ClassAttribute;
import e4sm.de.metamodel.e4sm.core.CorePackage;
import e4sm.de.metamodel.e4sm.core.DoubleAttribute;
import e4sm.de.metamodel.e4sm.core.IntegerAttribute;
import e4sm.de.metamodel.e4sm.core.LiteralBoolean;
import e4sm.de.metamodel.e4sm.core.LiteralByte;
import e4sm.de.metamodel.e4sm.core.LiteralCharacter;
import e4sm.de.metamodel.e4sm.core.LiteralDate;
import e4sm.de.metamodel.e4sm.core.LiteralDouble;
import e4sm.de.metamodel.e4sm.core.LiteralFloat;
import e4sm.de.metamodel.e4sm.core.LiteralInteger;
import e4sm.de.metamodel.e4sm.core.LiteralLong;
import e4sm.de.metamodel.e4sm.core.LiteralNull;
import e4sm.de.metamodel.e4sm.core.LiteralShort;
import e4sm.de.metamodel.e4sm.core.LiteralString;
import e4sm.de.metamodel.e4sm.core.StringAttribute;
import e4sm.de.metamodel.e4sm.core.TypeSpecification;
import e4sm.de.metamodel.e4sm.core.Variant;
import e4sm.de.metamodel.e4sm.e4smPackage;
import e4sm.de.metamodel.e4sm.execution.Addition;
import e4sm.de.metamodel.e4sm.execution.AssignableElementReference;
import e4sm.de.metamodel.e4sm.execution.Assignment;
import e4sm.de.metamodel.e4sm.execution.Const;
import e4sm.de.metamodel.e4sm.execution.Execution;
import e4sm.de.metamodel.e4sm.execution.ExecutionPackage;
import e4sm.de.metamodel.e4sm.execution.Flow;
import e4sm.de.metamodel.e4sm.execution.FlowFinal;
import e4sm.de.metamodel.e4sm.execution.ForkNode;
import e4sm.de.metamodel.e4sm.execution.InputPinAttributeReference;
import e4sm.de.metamodel.e4sm.execution.InputPinReference;
import e4sm.de.metamodel.e4sm.execution.MergeNode;
import e4sm.de.metamodel.e4sm.execution.Multiplication;
import e4sm.de.metamodel.e4sm.execution.ParameterReference;
import e4sm.de.metamodel.e4sm.execution.TimeFunction;
import e4sm.de.metamodel.e4sm.execution.Variable;
import e4sm.de.metamodel.e4sm.execution.VariableRef;
import e4sm.de.metamodel.xtext.services.E4smGrammarAccess;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.ecore.EAnnotation;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.EEnumLiteral;
import org.eclipse.emf.ecore.EGenericType;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EOperation;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EParameter;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.ETypeParameter;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class E4smSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private E4smGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AnalysisPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AnalysisPackage.PARAMETER:
				sequence_Parameter(context, (e4sm.de.metamodel.e4sm.analysis.Parameter) semanticObject); 
				return; 
			case AnalysisPackage.PARAMETER_DEFINITION:
				sequence_ParameterDefinition(context, (ParameterDefinition) semanticObject); 
				return; 
			}
		else if (epackage == CorePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CorePackage.BOOLEAN_ATTRIBUTE:
				sequence_BooleanAttribute(context, (BooleanAttribute) semanticObject); 
				return; 
			case CorePackage.CLASS_ATTRIBUTE:
				sequence_ClassAttribute(context, (ClassAttribute) semanticObject); 
				return; 
			case CorePackage.DOUBLE_ATTRIBUTE:
				sequence_DoubleAttribute(context, (DoubleAttribute) semanticObject); 
				return; 
			case CorePackage.INTEGER_ATTRIBUTE:
				sequence_IntegerAttribute(context, (IntegerAttribute) semanticObject); 
				return; 
			case CorePackage.LITERAL_BOOLEAN:
				sequence_LiteralBoolean(context, (LiteralBoolean) semanticObject); 
				return; 
			case CorePackage.LITERAL_BYTE:
				sequence_LiteralByte(context, (LiteralByte) semanticObject); 
				return; 
			case CorePackage.LITERAL_CHARACTER:
				sequence_LiteralCharacter(context, (LiteralCharacter) semanticObject); 
				return; 
			case CorePackage.LITERAL_DATE:
				sequence_LiteralDate(context, (LiteralDate) semanticObject); 
				return; 
			case CorePackage.LITERAL_DOUBLE:
				sequence_LiteralDouble(context, (LiteralDouble) semanticObject); 
				return; 
			case CorePackage.LITERAL_FLOAT:
				sequence_LiteralFloat(context, (LiteralFloat) semanticObject); 
				return; 
			case CorePackage.LITERAL_INTEGER:
				sequence_LiteralInteger(context, (LiteralInteger) semanticObject); 
				return; 
			case CorePackage.LITERAL_LONG:
				sequence_LiteralLong(context, (LiteralLong) semanticObject); 
				return; 
			case CorePackage.LITERAL_NULL:
				sequence_LiteralNull(context, (LiteralNull) semanticObject); 
				return; 
			case CorePackage.LITERAL_SHORT:
				sequence_LiteralShort(context, (LiteralShort) semanticObject); 
				return; 
			case CorePackage.LITERAL_STRING:
				sequence_LiteralString(context, (LiteralString) semanticObject); 
				return; 
			case CorePackage.STRING_ATTRIBUTE:
				sequence_StringAttribute(context, (StringAttribute) semanticObject); 
				return; 
			case CorePackage.TYPE_SPECIFICATION:
				sequence_TypeSpecification(context, (TypeSpecification) semanticObject); 
				return; 
			case CorePackage.VARIANT:
				sequence_Variant(context, (Variant) semanticObject); 
				return; 
			}
		else if (epackage == e4smPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case e4smPackage.ACTOR:
				sequence_Actor_Impl(context, (Actor) semanticObject); 
				return; 
			case e4smPackage.ACTUATOR:
				sequence_Actuator(context, (Actuator) semanticObject); 
				return; 
			case e4smPackage.BINARY_CLASSIFICATION_COMPONENT:
				sequence_BinaryClassificationComponent(context, (BinaryClassificationComponent) semanticObject); 
				return; 
			case e4smPackage.BINARY_CONFUSION_MATRIX:
				sequence_BinaryConfusionMatrix(context, (BinaryConfusionMatrix) semanticObject); 
				return; 
			case e4smPackage.CLASSIFICATION_CLASS:
				sequence_ClassificationClass(context, (ClassificationClass) semanticObject); 
				return; 
			case e4smPackage.CLASSIFICATION_CLASS_DISTRIBUTION:
				sequence_ClassificationClassDistribution(context, (ClassificationClassDistribution) semanticObject); 
				return; 
			case e4smPackage.COMPONENT:
				sequence_Component_Impl(context, (Component) semanticObject); 
				return; 
			case e4smPackage.CONFUSION_MATRIX_ENTRY:
				sequence_ConfusionMatrixEntry(context, (ConfusionMatrixEntry) semanticObject); 
				return; 
			case e4smPackage.CONNECTOR:
				sequence_Connector_Impl(context, (Connector) semanticObject); 
				return; 
			case e4smPackage.DATA_STORE:
				sequence_DataStore(context, (DataStore) semanticObject); 
				return; 
			case e4smPackage.ENVIRONMENT:
				sequence_Environment(context, (Environment) semanticObject); 
				return; 
			case e4smPackage.EXTERNAL_DEPENDENCY:
				sequence_ExternalDependency(context, (ExternalDependency) semanticObject); 
				return; 
			case e4smPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case e4smPackage.HEURISTIC:
				sequence_Heuristic(context, (Heuristic) semanticObject); 
				return; 
			case e4smPackage.HUMAN:
				sequence_Human_Impl(context, (Human) semanticObject); 
				return; 
			case e4smPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case e4smPackage.INPUT_PIN:
				sequence_InputPin(context, (InputPin) semanticObject); 
				return; 
			case e4smPackage.LOGICAL_CONNECTOR:
				sequence_LogicalConnector(context, (LogicalConnector) semanticObject); 
				return; 
			case e4smPackage.MACHINE_LEARNING_COMPONENT:
				sequence_MachineLearningComponent(context, (MachineLearningComponent) semanticObject); 
				return; 
			case e4smPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case e4smPackage.MULTICLASS_CLASSIFICATION_COMPONENT:
				sequence_MulticlassClassificationComponent(context, (MulticlassClassificationComponent) semanticObject); 
				return; 
			case e4smPackage.MULTICLASS_CONFUSION_MATRIX:
				sequence_MulticlassConfusionMatrix(context, (MulticlassConfusionMatrix) semanticObject); 
				return; 
			case e4smPackage.OUTPUT_PIN:
				sequence_OutputPin(context, (OutputPin) semanticObject); 
				return; 
			case e4smPackage.PACKAGE:
				sequence_Package(context, (e4sm.de.metamodel.e4sm.Package) semanticObject); 
				return; 
			case e4smPackage.PERSON:
				sequence_Person(context, (Person) semanticObject); 
				return; 
			case e4smPackage.PHYSICAL_COMPONENT:
				sequence_PhysicalComponent_Impl(context, (PhysicalComponent) semanticObject); 
				return; 
			case e4smPackage.PHYSICAL_CONNECTOR:
				sequence_PhysicalConnector(context, (PhysicalConnector) semanticObject); 
				return; 
			case e4smPackage.ROBOT:
				sequence_Robot(context, (Robot) semanticObject); 
				return; 
			case e4smPackage.SECTOR:
				sequence_Sector(context, (Sector) semanticObject); 
				return; 
			case e4smPackage.SENSOR:
				sequence_Sensor(context, (Sensor) semanticObject); 
				return; 
			case e4smPackage.SOFTWARE_COMPONENT:
				sequence_SoftwareComponent_Impl(context, (SoftwareComponent) semanticObject); 
				return; 
			}
		else if (epackage == EcorePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EcorePackage.EANNOTATION:
				sequence_EAnnotation(context, (EAnnotation) semanticObject); 
				return; 
			case EcorePackage.EATTRIBUTE:
				sequence_EAttribute(context, (EAttribute) semanticObject); 
				return; 
			case EcorePackage.ECLASS:
				sequence_EClass(context, (EClass) semanticObject); 
				return; 
			case EcorePackage.EDATA_TYPE:
				sequence_EDataType_Impl(context, (EDataType) semanticObject); 
				return; 
			case EcorePackage.EENUM:
				sequence_EEnum(context, (EEnum) semanticObject); 
				return; 
			case EcorePackage.EENUM_LITERAL:
				sequence_EEnumLiteral(context, (EEnumLiteral) semanticObject); 
				return; 
			case EcorePackage.EGENERIC_TYPE:
				sequence_EGenericType(context, (EGenericType) semanticObject); 
				return; 
			case EcorePackage.EOBJECT:
				sequence_EObject(context, (EObject) semanticObject); 
				return; 
			case EcorePackage.EOPERATION:
				sequence_EOperation(context, (EOperation) semanticObject); 
				return; 
			case EcorePackage.EPARAMETER:
				sequence_EParameter(context, (EParameter) semanticObject); 
				return; 
			case EcorePackage.EREFERENCE:
				sequence_EReference(context, (EReference) semanticObject); 
				return; 
			case EcorePackage.ESTRING_TO_STRING_MAP_ENTRY:
				sequence_EStringToStringMapEntry(context, (Map.Entry) semanticObject); 
				return; 
			case EcorePackage.ETYPE_PARAMETER:
				sequence_ETypeParameter(context, (ETypeParameter) semanticObject); 
				return; 
			}
		else if (epackage == ExecutionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExecutionPackage.ADDITION:
				sequence_Addition(context, (Addition) semanticObject); 
				return; 
			case ExecutionPackage.ASSIGNABLE_ELEMENT_REFERENCE:
				sequence_AssignableElementReference(context, (AssignableElementReference) semanticObject); 
				return; 
			case ExecutionPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case ExecutionPackage.CONST:
				sequence_Const(context, (Const) semanticObject); 
				return; 
			case ExecutionPackage.EXECUTION:
				sequence_Execution(context, (Execution) semanticObject); 
				return; 
			case ExecutionPackage.FLOW:
				sequence_Flow(context, (Flow) semanticObject); 
				return; 
			case ExecutionPackage.FLOW_FINAL:
				sequence_FlowFinal(context, (FlowFinal) semanticObject); 
				return; 
			case ExecutionPackage.FORK_NODE:
				sequence_ForkNode(context, (ForkNode) semanticObject); 
				return; 
			case ExecutionPackage.INPUT_PIN_ATTRIBUTE_REFERENCE:
				sequence_InputPinAttributeReference(context, (InputPinAttributeReference) semanticObject); 
				return; 
			case ExecutionPackage.INPUT_PIN_REFERENCE:
				sequence_InputPinReference(context, (InputPinReference) semanticObject); 
				return; 
			case ExecutionPackage.MERGE_NODE:
				sequence_MergeNode(context, (MergeNode) semanticObject); 
				return; 
			case ExecutionPackage.MULTIPLICATION:
				sequence_Multiplication(context, (Multiplication) semanticObject); 
				return; 
			case ExecutionPackage.PARAMETER_REFERENCE:
				sequence_ParameterReference(context, (ParameterReference) semanticObject); 
				return; 
			case ExecutionPackage.TIME_FUNCTION:
				sequence_ExeTimeFunction(context, (TimeFunction) semanticObject); 
				return; 
			case ExecutionPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case ExecutionPackage.VARIABLE_REF:
				sequence_VariableRef(context, (VariableRef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Actor returns Actor
	 *     Actor_Impl returns Actor
	 *
	 * Constraint:
	 *     (name=EString documentation=EString?)
	 * </pre>
	 */
	protected void sequence_Actor_Impl(ISerializationContext context, Actor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Actuator
	 *     Actuator returns Actuator
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution?
	 *     )
	 * </pre>
	 */
	protected void sequence_Actuator(ISerializationContext context, Actuator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Elements returns Addition
	 *     Expression returns Addition
	 *     Addition returns Addition
	 *     Addition.Addition_2_0 returns Addition
	 *     Primary returns Addition
	 *
	 * Constraint:
	 *     (left=Multiplication | (left=Addition_Addition_2_0 (addition?='+' | subtraction?='-') right=Multiplication))
	 * </pre>
	 */
	protected void sequence_Addition(ISerializationContext context, Addition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignableElementReference returns AssignableElementReference
	 *
	 * Constraint:
	 *     ref=[AssignableElement|ID]
	 * </pre>
	 */
	protected void sequence_AssignableElementReference(ISerializationContext context, AssignableElementReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExecutionPackage.Literals.ASSIGNABLE_ELEMENT_REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExecutionPackage.Literals.ASSIGNABLE_ELEMENT_REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignableElementReferenceAccess().getRefAssignableElementIDTerminalRuleCall_0_1(), semanticObject.eGet(ExecutionPackage.Literals.ASSIGNABLE_ELEMENT_REFERENCE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Elements returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (target=AssignableElementReference expression=Expression)
	 * </pre>
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExecutionPackage.Literals.ASSIGNMENT__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExecutionPackage.Literals.ASSIGNMENT__TARGET));
			if (transientValues.isValueTransient(semanticObject, ExecutionPackage.Literals.ASSIGNMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExecutionPackage.Literals.ASSIGNMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getTargetAssignableElementReferenceParserRuleCall_0_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getAssignmentAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns BinaryClassificationComponent
	 *     ClassificationComponent returns BinaryClassificationComponent
	 *     BinaryClassificationComponent returns BinaryClassificationComponent
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         synchronous=EBoolean? 
	 *         numberOfServers=EInt? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution? 
	 *         (confusionMatrixes+=BinaryConfusionMatrix confusionMatrixes+=BinaryConfusionMatrix*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_BinaryClassificationComponent(ISerializationContext context, BinaryClassificationComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConfusionMatrix returns BinaryConfusionMatrix
	 *     BinaryConfusionMatrix returns BinaryConfusionMatrix
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (positiveClass=[ClassificationClass|EString] negativeClass=[ClassificationClass|EString]?)? 
	 *         tp=EInt 
	 *         fn=EInt 
	 *         fp=EInt 
	 *         tn=EInt
	 *     )
	 * </pre>
	 */
	protected void sequence_BinaryConfusionMatrix(ISerializationContext context, BinaryConfusionMatrix semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeSpecification returns BooleanAttribute
	 *     BooleanAttribute returns BooleanAttribute
	 *
	 * Constraint:
	 *     (array?='['? name=ID defaultValue=EBoolean?)
	 * </pre>
	 */
	protected void sequence_BooleanAttribute(ISerializationContext context, BooleanAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeSpecification returns ClassAttribute
	 *     ClassAttribute returns ClassAttribute
	 *
	 * Constraint:
	 *     (type=[TypeSpecification|ID] array?='['? name=ID)
	 * </pre>
	 */
	protected void sequence_ClassAttribute(ISerializationContext context, ClassAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ClassificationClassDistribution returns ClassificationClassDistribution
	 *
	 * Constraint:
	 *     (classificationClass=[ClassificationClass|ID] probability=EDouble)
	 * </pre>
	 */
	protected void sequence_ClassificationClassDistribution(ISerializationContext context, ClassificationClassDistribution semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, e4smPackage.Literals.CLASSIFICATION_CLASS_DISTRIBUTION__CLASSIFICATION_CLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, e4smPackage.Literals.CLASSIFICATION_CLASS_DISTRIBUTION__CLASSIFICATION_CLASS));
			if (transientValues.isValueTransient(semanticObject, e4smPackage.Literals.CLASSIFICATION_CLASS_DISTRIBUTION__PROBABILITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, e4smPackage.Literals.CLASSIFICATION_CLASS_DISTRIBUTION__PROBABILITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassificationClassDistributionAccess().getClassificationClassClassificationClassIDTerminalRuleCall_1_0_1(), semanticObject.eGet(e4smPackage.Literals.CLASSIFICATION_CLASS_DISTRIBUTION__CLASSIFICATION_CLASS, false));
		feeder.accept(grammarAccess.getClassificationClassDistributionAccess().getProbabilityEDoubleParserRuleCall_2_0(), semanticObject.getProbability());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ClassificationClass returns ClassificationClass
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_ClassificationClass(ISerializationContext context, ClassificationClass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CorePackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CorePackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassificationClassAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Component
	 *     Component_Impl returns Component
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution?
	 *     )
	 * </pre>
	 */
	protected void sequence_Component_Impl(ISerializationContext context, Component semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConfusionMatrixEntry returns ConfusionMatrixEntry
	 *
	 * Constraint:
	 *     (truth=[ClassificationClass|EString] predicted=[ClassificationClass|EString] value=EInt)
	 * </pre>
	 */
	protected void sequence_ConfusionMatrixEntry(ISerializationContext context, ConfusionMatrixEntry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, e4smPackage.Literals.CONFUSION_MATRIX_ENTRY__TRUTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, e4smPackage.Literals.CONFUSION_MATRIX_ENTRY__TRUTH));
			if (transientValues.isValueTransient(semanticObject, e4smPackage.Literals.CONFUSION_MATRIX_ENTRY__PREDICTED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, e4smPackage.Literals.CONFUSION_MATRIX_ENTRY__PREDICTED));
			if (transientValues.isValueTransient(semanticObject, e4smPackage.Literals.CONFUSION_MATRIX_ENTRY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, e4smPackage.Literals.CONFUSION_MATRIX_ENTRY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConfusionMatrixEntryAccess().getTruthClassificationClassEStringParserRuleCall_1_0_1(), semanticObject.eGet(e4smPackage.Literals.CONFUSION_MATRIX_ENTRY__TRUTH, false));
		feeder.accept(grammarAccess.getConfusionMatrixEntryAccess().getPredictedClassificationClassEStringParserRuleCall_2_0_1(), semanticObject.eGet(e4smPackage.Literals.CONFUSION_MATRIX_ENTRY__PREDICTED, false));
		feeder.accept(grammarAccess.getConfusionMatrixEntryAccess().getValueEIntParserRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Connector returns Connector
	 *     Connector_Impl returns Connector
	 *
	 * Constraint:
	 *     (name=EString source=[Pin|EString] target=[Pin|EString] documentation=EString? (parameters+=Parameter parameters+=Parameter*)?)
	 * </pre>
	 */
	protected void sequence_Connector_Impl(ISerializationContext context, Connector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Elements returns Const
	 *     ReferenceableItem returns Const
	 *     Const returns Const
	 *
	 * Constraint:
	 *     (name=ID expression=Expression?)
	 * </pre>
	 */
	protected void sequence_Const(ISerializationContext context, Const semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataStore returns DataStore
	 *     DataNode returns DataStore
	 *
	 * Constraint:
	 *     (type=[TypeSpecification|ID]? name=EString documentation=EString? (parameters+=Parameter parameters+=Parameter*)?)
	 * </pre>
	 */
	protected void sequence_DataStore(ISerializationContext context, DataStore semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeSpecification returns DoubleAttribute
	 *     DoubleAttribute returns DoubleAttribute
	 *
	 * Constraint:
	 *     (array?='['? name=ID defaultValue=EDouble?)
	 * </pre>
	 */
	protected void sequence_DoubleAttribute(ISerializationContext context, DoubleAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EAnnotation returns EAnnotation
	 *
	 * Constraint:
	 *     (
	 *         source=EString? 
	 *         (references+=[EObject|EString] references+=[EObject|EString]*)? 
	 *         (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)? 
	 *         (details+=EStringToStringMapEntry details+=EStringToStringMapEntry*)? 
	 *         (contents+=EObject contents+=EObject*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_EAnnotation(ISerializationContext context, EAnnotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EStructuralFeature returns EAttribute
	 *     EAttribute returns EAttribute
	 *
	 * Constraint:
	 *     (
	 *         volatile?='volatile'? 
	 *         transient?='transient'? 
	 *         unsettable?='unsettable'? 
	 *         derived?='derived'? 
	 *         iD?='iD'? 
	 *         name=EString 
	 *         ordered=EBoolean? 
	 *         unique=EBoolean? 
	 *         lowerBound=EInt? 
	 *         upperBound=EInt? 
	 *         changeable=EBoolean? 
	 *         defaultValueLiteral=EString? 
	 *         eType=[EClassifier|EString]? 
	 *         (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)? 
	 *         eGenericType=EGenericType?
	 *     )
	 * </pre>
	 */
	protected void sequence_EAttribute(ISerializationContext context, EAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EClassifier returns EClass
	 *     EClass returns EClass
	 *
	 * Constraint:
	 *     (
	 *         abstract?='abstract'? 
	 *         interface?='interface'? 
	 *         name=EString 
	 *         instanceClassName=EString? 
	 *         instanceTypeName=EString? 
	 *         (eSuperTypes+=[EClass|EString] eSuperTypes+=[EClass|EString]*)? 
	 *         (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)? 
	 *         (eTypeParameters+=ETypeParameter eTypeParameters+=ETypeParameter*)? 
	 *         (eOperations+=EOperation eOperations+=EOperation*)? 
	 *         (eStructuralFeatures+=EStructuralFeature eStructuralFeatures+=EStructuralFeature*)? 
	 *         (eGenericSuperTypes+=EGenericType eGenericSuperTypes+=EGenericType*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_EClass(ISerializationContext context, EClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EDataType returns EDataType
	 *     EClassifier returns EDataType
	 *     EDataType_Impl returns EDataType
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         instanceClassName=EString? 
	 *         instanceTypeName=EString? 
	 *         serializable=EBoolean? 
	 *         (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)? 
	 *         (eTypeParameters+=ETypeParameter eTypeParameters+=ETypeParameter*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_EDataType_Impl(ISerializationContext context, EDataType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EEnumLiteral returns EEnumLiteral
	 *
	 * Constraint:
	 *     (name=EString value=EInt? literal=EString? (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)?)
	 * </pre>
	 */
	protected void sequence_EEnumLiteral(ISerializationContext context, EEnumLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EDataType returns EEnum
	 *     EClassifier returns EEnum
	 *     EEnum returns EEnum
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         instanceClassName=EString? 
	 *         instanceTypeName=EString? 
	 *         serializable=EBoolean? 
	 *         (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)? 
	 *         (eTypeParameters+=ETypeParameter eTypeParameters+=ETypeParameter*)? 
	 *         (eLiterals+=EEnumLiteral eLiterals+=EEnumLiteral*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_EEnum(ISerializationContext context, EEnum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EGenericType returns EGenericType
	 *
	 * Constraint:
	 *     (
	 *         eTypeParameter=[ETypeParameter|EString]? 
	 *         eClassifier=[EClassifier|EString]? 
	 *         eUpperBound=EGenericType? 
	 *         (eTypeArguments+=EGenericType eTypeArguments+=EGenericType*)? 
	 *         eLowerBound=EGenericType?
	 *     )
	 * </pre>
	 */
	protected void sequence_EGenericType(ISerializationContext context, EGenericType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EObject returns EObject
	 *
	 * Constraint:
	 *     {EObject}
	 * </pre>
	 */
	protected void sequence_EObject(ISerializationContext context, EObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EOperation returns EOperation
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         ordered=EBoolean? 
	 *         unique=EBoolean? 
	 *         lowerBound=EInt? 
	 *         upperBound=EInt? 
	 *         eType=[EClassifier|EString]? 
	 *         (eExceptions+=[EClassifier|EString] eExceptions+=[EClassifier|EString]*)? 
	 *         (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)? 
	 *         eGenericType=EGenericType? 
	 *         (eTypeParameters+=ETypeParameter eTypeParameters+=ETypeParameter*)? 
	 *         (eParameters+=EParameter eParameters+=EParameter*)? 
	 *         (eGenericExceptions+=EGenericType eGenericExceptions+=EGenericType*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_EOperation(ISerializationContext context, EOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EParameter returns EParameter
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         ordered=EBoolean? 
	 *         unique=EBoolean? 
	 *         lowerBound=EInt? 
	 *         upperBound=EInt? 
	 *         eType=[EClassifier|EString]? 
	 *         (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)? 
	 *         eGenericType=EGenericType?
	 *     )
	 * </pre>
	 */
	protected void sequence_EParameter(ISerializationContext context, EParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EStructuralFeature returns EReference
	 *     EReference returns EReference
	 *
	 * Constraint:
	 *     (
	 *         volatile?='volatile'? 
	 *         transient?='transient'? 
	 *         unsettable?='unsettable'? 
	 *         derived?='derived'? 
	 *         containment?='containment'? 
	 *         name=EString 
	 *         ordered=EBoolean? 
	 *         unique=EBoolean? 
	 *         lowerBound=EInt? 
	 *         upperBound=EInt? 
	 *         changeable=EBoolean? 
	 *         defaultValueLiteral=EString? 
	 *         resolveProxies=EBoolean? 
	 *         eType=[EClassifier|EString]? 
	 *         eOpposite=[EReference|EString]? 
	 *         (eKeys+=[EAttribute|EString] eKeys+=[EAttribute|EString]*)? 
	 *         (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)? 
	 *         eGenericType=EGenericType?
	 *     )
	 * </pre>
	 */
	protected void sequence_EReference(ISerializationContext context, EReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EStringToStringMapEntry returns EStringToStringMapEntry
	 *
	 * Constraint:
	 *     (key=EString? value=EString?)
	 * </pre>
	 */
	protected void sequence_EStringToStringMapEntry(ISerializationContext context, Map.Entry semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ETypeParameter returns ETypeParameter
	 *
	 * Constraint:
	 *     (name=EString (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)? (eBounds+=EGenericType eBounds+=EGenericType*)?)
	 * </pre>
	 */
	protected void sequence_ETypeParameter(ISerializationContext context, ETypeParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Environment returns Environment
	 *
	 * Constraint:
	 *     (name=EString (classificationClasses+=ClassificationClassDistribution classificationClasses+=ClassificationClassDistribution*)?)
	 * </pre>
	 */
	protected void sequence_Environment(ISerializationContext context, Environment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ComplexTimefunction returns TimeFunction
	 *     ExeTimeFunction returns TimeFunction
	 *
	 * Constraint:
	 *     (function=TimeFunctions par1=Expression par2=Expression?)
	 * </pre>
	 */
	protected void sequence_ExeTimeFunction(ISerializationContext context, TimeFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Execution returns Execution
	 *
	 * Constraint:
	 *     elements+=Elements+
	 * </pre>
	 */
	protected void sequence_Execution(ISerializationContext context, Execution semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns ExternalDependency
	 *     ExternalDependency returns ExternalDependency
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         synchronous=EBoolean? 
	 *         numberOfServers=EInt? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution?
	 *     )
	 * </pre>
	 */
	protected void sequence_ExternalDependency(ISerializationContext context, ExternalDependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Elements returns FlowFinal
	 *     ConnectableNode returns FlowFinal
	 *     FlowFinal returns FlowFinal
	 *
	 * Constraint:
	 *     source=[ConnectableNode|ID]
	 * </pre>
	 */
	protected void sequence_FlowFinal(ISerializationContext context, FlowFinal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExecutionPackage.Literals.FLOW_FINAL__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExecutionPackage.Literals.FLOW_FINAL__SOURCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFlowFinalAccess().getSourceConnectableNodeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ExecutionPackage.Literals.FLOW_FINAL__SOURCE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Elements returns Flow
	 *     Flow returns Flow
	 *
	 * Constraint:
	 *     (source=[ConnectableNode|ID] target=[ConnectableNode|ID] timeFunction=ComplexTimefunction?)
	 * </pre>
	 */
	protected void sequence_Flow(ISerializationContext context, Flow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Elements returns ForkNode
	 *     ConnectableNode returns ForkNode
	 *     ForkNode returns ForkNode
	 *
	 * Constraint:
	 *     (source=[ConnectableNode|ID] targets+=[ConnectableNode|ID] targets+=[ConnectableNode|ID]* timeFunction=ComplexTimefunction?)
	 * </pre>
	 */
	protected void sequence_ForkNode(ISerializationContext context, ForkNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Function
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         synchronous=EBoolean? 
	 *         numberOfServers=EInt? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution?
	 *     )
	 * </pre>
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Heuristic
	 *     Heuristic returns Heuristic
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         synchronous=EBoolean? 
	 *         numberOfServers=EInt? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution?
	 *     )
	 * </pre>
	 */
	protected void sequence_Heuristic(ISerializationContext context, Heuristic semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Actor returns Human
	 *     Human_Impl returns Human
	 *
	 * Constraint:
	 *     (name=EString documentation=EString?)
	 * </pre>
	 */
	protected void sequence_Human_Impl(ISerializationContext context, Human semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     referencedModel=[Model|STRING]
	 * </pre>
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, e4smPackage.Literals.IMPORT__REFERENCED_MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, e4smPackage.Literals.IMPORT__REFERENCED_MODEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getReferencedModelModelSTRINGTerminalRuleCall_2_0_1(), semanticObject.eGet(e4smPackage.Literals.IMPORT__REFERENCED_MODEL, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary returns InputPinAttributeReference
	 *     InputPinAttributeReference returns InputPinAttributeReference
	 *
	 * Constraint:
	 *     (inputPin=[InputPin|ID] attribute=[AttributeSpecification|ID])
	 * </pre>
	 */
	protected void sequence_InputPinAttributeReference(ISerializationContext context, InputPinAttributeReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExecutionPackage.Literals.INPUT_PIN_REFERENCE__INPUT_PIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExecutionPackage.Literals.INPUT_PIN_REFERENCE__INPUT_PIN));
			if (transientValues.isValueTransient(semanticObject, ExecutionPackage.Literals.INPUT_PIN_ATTRIBUTE_REFERENCE__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExecutionPackage.Literals.INPUT_PIN_ATTRIBUTE_REFERENCE__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputPinAttributeReferenceAccess().getInputPinInputPinIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ExecutionPackage.Literals.INPUT_PIN_REFERENCE__INPUT_PIN, false));
		feeder.accept(grammarAccess.getInputPinAttributeReferenceAccess().getAttributeAttributeSpecificationIDTerminalRuleCall_4_0_1(), semanticObject.eGet(ExecutionPackage.Literals.INPUT_PIN_ATTRIBUTE_REFERENCE__ATTRIBUTE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary returns InputPinReference
	 *     InputPinReference returns InputPinReference
	 *
	 * Constraint:
	 *     inputPin=[InputPin|ID]
	 * </pre>
	 */
	protected void sequence_InputPinReference(ISerializationContext context, InputPinReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExecutionPackage.Literals.INPUT_PIN_REFERENCE__INPUT_PIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExecutionPackage.Literals.INPUT_PIN_REFERENCE__INPUT_PIN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputPinReferenceAccess().getInputPinInputPinIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ExecutionPackage.Literals.INPUT_PIN_REFERENCE__INPUT_PIN, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataNode returns InputPin
	 *     Pin returns InputPin
	 *     InputPin returns InputPin
	 *
	 * Constraint:
	 *     (
	 *         optional?='optional'? 
	 *         stream?='stream'? 
	 *         type=[TypeSpecification|ID]? 
	 *         name=EString 
	 *         documentation=EString? 
	 *         collect=EInt? 
	 *         raceSemantic=RaceSemantic? 
	 *         queueType=QueueType? 
	 *         (parameters+=Parameter parameters+=Parameter*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_InputPin(ISerializationContext context, InputPin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeSpecification returns IntegerAttribute
	 *     IntegerAttribute returns IntegerAttribute
	 *
	 * Constraint:
	 *     (array?='['? name=ID defaultValue=EInt?)
	 * </pre>
	 */
	protected void sequence_IntegerAttribute(ISerializationContext context, IntegerAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralBoolean
	 *     LiteralBoolean returns LiteralBoolean
	 *     Primary returns LiteralBoolean
	 *
	 * Constraint:
	 *     value?='true'?
	 * </pre>
	 */
	protected void sequence_LiteralBoolean(ISerializationContext context, LiteralBoolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralByte
	 *     LiteralByte returns LiteralByte
	 *     Primary returns LiteralByte
	 *
	 * Constraint:
	 *     (name=EString value=Byte?)
	 * </pre>
	 */
	protected void sequence_LiteralByte(ISerializationContext context, LiteralByte semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralCharacter
	 *     LiteralCharacter returns LiteralCharacter
	 *     Primary returns LiteralCharacter
	 *
	 * Constraint:
	 *     (name=EString value=Character?)
	 * </pre>
	 */
	protected void sequence_LiteralCharacter(ISerializationContext context, LiteralCharacter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralDate
	 *     LiteralDate returns LiteralDate
	 *     Primary returns LiteralDate
	 *
	 * Constraint:
	 *     (name=EString value=Date?)
	 * </pre>
	 */
	protected void sequence_LiteralDate(ISerializationContext context, LiteralDate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralDouble
	 *     LiteralDouble returns LiteralDouble
	 *     Primary returns LiteralDouble
	 *
	 * Constraint:
	 *     value=EDouble
	 * </pre>
	 */
	protected void sequence_LiteralDouble(ISerializationContext context, LiteralDouble semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CorePackage.Literals.LITERAL_DOUBLE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CorePackage.Literals.LITERAL_DOUBLE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralDoubleAccess().getValueEDoubleParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralFloat
	 *     LiteralFloat returns LiteralFloat
	 *     Primary returns LiteralFloat
	 *
	 * Constraint:
	 *     value=Float
	 * </pre>
	 */
	protected void sequence_LiteralFloat(ISerializationContext context, LiteralFloat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CorePackage.Literals.LITERAL_FLOAT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CorePackage.Literals.LITERAL_FLOAT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralFloatAccess().getValueFloatParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralInteger
	 *     Primary returns LiteralInteger
	 *     LiteralInteger returns LiteralInteger
	 *
	 * Constraint:
	 *     value=EInt
	 * </pre>
	 */
	protected void sequence_LiteralInteger(ISerializationContext context, LiteralInteger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CorePackage.Literals.LITERAL_INTEGER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CorePackage.Literals.LITERAL_INTEGER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralIntegerAccess().getValueEIntParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralLong
	 *     LiteralLong returns LiteralLong
	 *     Primary returns LiteralLong
	 *
	 * Constraint:
	 *     value=Long
	 * </pre>
	 */
	protected void sequence_LiteralLong(ISerializationContext context, LiteralLong semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CorePackage.Literals.LITERAL_LONG__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CorePackage.Literals.LITERAL_LONG__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralLongAccess().getValueLongParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralNull
	 *     LiteralNull returns LiteralNull
	 *     Primary returns LiteralNull
	 *
	 * Constraint:
	 *     {LiteralNull}
	 * </pre>
	 */
	protected void sequence_LiteralNull(ISerializationContext context, LiteralNull semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralShort
	 *     LiteralShort returns LiteralShort
	 *     Primary returns LiteralShort
	 *
	 * Constraint:
	 *     (name=EString value=Short?)
	 * </pre>
	 */
	protected void sequence_LiteralShort(ISerializationContext context, LiteralShort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralString
	 *     LiteralString returns LiteralString
	 *     Primary returns LiteralString
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_LiteralString(ISerializationContext context, LiteralString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CorePackage.Literals.LITERAL_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CorePackage.Literals.LITERAL_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralStringAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Connector returns LogicalConnector
	 *     LogicalConnector returns LogicalConnector
	 *
	 * Constraint:
	 *     (name=EString source=[Pin|EString] target=[Pin|EString] documentation=EString? (parameters+=Parameter parameters+=Parameter*)?)
	 * </pre>
	 */
	protected void sequence_LogicalConnector(ISerializationContext context, LogicalConnector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns MachineLearningComponent
	 *     MachineLearningComponent returns MachineLearningComponent
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         synchronous=EBoolean? 
	 *         numberOfServers=EInt? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution?
	 *     )
	 * </pre>
	 */
	protected void sequence_MachineLearningComponent(ISerializationContext context, MachineLearningComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Elements returns MergeNode
	 *     ConnectableNode returns MergeNode
	 *     MergeNode returns MergeNode
	 *
	 * Constraint:
	 *     (sources+=[ConnectableNode|ID] sources+=[ConnectableNode|ID]* timeFunction=ComplexTimefunction? target=[ConnectableNode|ID])
	 * </pre>
	 */
	protected void sequence_MergeNode(ISerializationContext context, MergeNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         (imports+=Import imports+=Import*)? 
	 *         personsPicturesPath=EString? 
	 *         (types+=TypeSpecification types+=TypeSpecification*)? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (packages+=Package packages+=Package*)? 
	 *         (actors+=Actor actors+=Actor*)? 
	 *         (variants+=Variant variants+=Variant*)? 
	 *         (classificationClasses+=ClassificationClass classificationClasses+=ClassificationClass*)? 
	 *         (environments+=Environment environments+=Environment*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns MulticlassClassificationComponent
	 *     ClassificationComponent returns MulticlassClassificationComponent
	 *     MulticlassClassificationComponent returns MulticlassClassificationComponent
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         synchronous=EBoolean? 
	 *         numberOfServers=EInt? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution? 
	 *         (confusionMatrixes+=MulticlassConfusionMatrix confusionMatrixes+=MulticlassConfusionMatrix*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_MulticlassClassificationComponent(ISerializationContext context, MulticlassClassificationComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConfusionMatrix returns MulticlassConfusionMatrix
	 *     MulticlassConfusionMatrix returns MulticlassConfusionMatrix
	 *
	 * Constraint:
	 *     (name=EString (entries+=ConfusionMatrixEntry entries+=ConfusionMatrixEntry*)?)
	 * </pre>
	 */
	protected void sequence_MulticlassConfusionMatrix(ISerializationContext context, MulticlassConfusionMatrix semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Multiplication returns Multiplication
	 *     Multiplication.Multiplication_2_0 returns Multiplication
	 *
	 * Constraint:
	 *     (left=Primary | (left=Multiplication_Multiplication_2_0 (multiplication?='*' | division?='/') right=Primary))
	 * </pre>
	 */
	protected void sequence_Multiplication(ISerializationContext context, Multiplication semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataNode returns OutputPin
	 *     Pin returns OutputPin
	 *     OutputPin returns OutputPin
	 *     AssignableElement returns OutputPin
	 *
	 * Constraint:
	 *     (
	 *         stream?='stream'? 
	 *         type=[TypeSpecification|ID]? 
	 *         name=EString 
	 *         documentation=EString? 
	 *         amplify=EInt? 
	 *         outputUncertainty=EDouble? 
	 *         raceSemantic=RaceSemantic? 
	 *         (parameters+=Parameter parameters+=Parameter*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_OutputPin(ISerializationContext context, OutputPin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Package returns Package
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiesComponent=[Component|EString]? 
	 *         processingUnits=EInt? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (connectors+=Connector connectors+=Connector*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         (sectors+=Sector sectors+=Sector*)? 
	 *         (packages+=Package packages+=Package*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Package(ISerializationContext context, e4sm.de.metamodel.e4sm.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterDefinition returns ParameterDefinition
	 *
	 * Constraint:
	 *     (name=EString unit=UnitOfMeasurement? (parameters+=[Parameter|EString] parameters+=[Parameter|EString]*)? defaultValue=ValueSpecification?)
	 * </pre>
	 */
	protected void sequence_ParameterDefinition(ISerializationContext context, ParameterDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary returns ParameterReference
	 *     ParameterReference returns ParameterReference
	 *
	 * Constraint:
	 *     parameter=[Parameter|ID]
	 * </pre>
	 */
	protected void sequence_ParameterReference(ISerializationContext context, ParameterReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExecutionPackage.Literals.PARAMETER_REFERENCE__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExecutionPackage.Literals.PARAMETER_REFERENCE__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterReferenceAccess().getParameterParameterIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ExecutionPackage.Literals.PARAMETER_REFERENCE__PARAMETER, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         initialValue=ValueSpecification? 
	 *         parameterDefinition=[ParameterDefinition|EString]? 
	 *         (appliesOnlyOnVariants+=[Variant|EString] appliesOnlyOnVariants+=[Variant|EString]*)? 
	 *         (doesNotApplyOnVariants+=[Variant|EString] doesNotApplyOnVariants+=[Variant|EString]*)? 
	 *         currentValue=ValueSpecification?
	 *     )
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, e4sm.de.metamodel.e4sm.analysis.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Actor returns Person
	 *     Person returns Person
	 *
	 * Constraint:
	 *     ((name=EString | (surname=EString name=EString)) documentation=EString? department=EString? pictureFileName=EString?)
	 * </pre>
	 */
	protected void sequence_Person(ISerializationContext context, Person semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns PhysicalComponent
	 *     PhysicalComponent_Impl returns PhysicalComponent
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution?
	 *     )
	 * </pre>
	 */
	protected void sequence_PhysicalComponent_Impl(ISerializationContext context, PhysicalComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Connector returns PhysicalConnector
	 *     PhysicalConnector returns PhysicalConnector
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         source=[Pin|EString] 
	 *         target=[Pin|EString] 
	 *         documentation=EString? 
	 *         minSpeed=Connectionspeed? 
	 *         maxSpeed=Connectionspeed? 
	 *         (parameters+=Parameter parameters+=Parameter*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_PhysicalConnector(ISerializationContext context, PhysicalConnector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Actor returns Robot
	 *     Robot returns Robot
	 *
	 * Constraint:
	 *     (name=EString documentation=EString?)
	 * </pre>
	 */
	protected void sequence_Robot(ISerializationContext context, Robot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Sector returns Sector
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         (sectors+=Sector sectors+=Sector*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Sector(ISerializationContext context, Sector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Sensor
	 *     Sensor returns Sensor
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution?
	 *     )
	 * </pre>
	 */
	protected void sequence_Sensor(ISerializationContext context, Sensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns SoftwareComponent
	 *     SoftwareComponent_Impl returns SoftwareComponent
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         synchronous=EBoolean? 
	 *         numberOfServers=EInt? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution?
	 *     )
	 * </pre>
	 */
	protected void sequence_SoftwareComponent_Impl(ISerializationContext context, SoftwareComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeSpecification returns StringAttribute
	 *     StringAttribute returns StringAttribute
	 *
	 * Constraint:
	 *     (array?='['? name=ID defaultValue=EString?)
	 * </pre>
	 */
	protected void sequence_StringAttribute(ISerializationContext context, StringAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeSpecification returns TypeSpecification
	 *
	 * Constraint:
	 *     (abstract?='abstract'? name=ID superType=[TypeSpecification|ID]? (attributes+=AttributeSpecification attributes+=AttributeSpecification*)?)
	 * </pre>
	 */
	protected void sequence_TypeSpecification(ISerializationContext context, TypeSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary returns VariableRef
	 *     VariableRef returns VariableRef
	 *
	 * Constraint:
	 *     variable=[ReferenceableItem|ID]
	 * </pre>
	 */
	protected void sequence_VariableRef(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExecutionPackage.Literals.VARIABLE_REF__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExecutionPackage.Literals.VARIABLE_REF__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableRefAccess().getVariableReferenceableItemIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ExecutionPackage.Literals.VARIABLE_REF__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Elements returns Variable
	 *     AssignableElement returns Variable
	 *     ReferenceableItem returns Variable
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (name=ID expression=Expression?)
	 * </pre>
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Variant returns Variant
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_Variant(ISerializationContext context, Variant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CorePackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CorePackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariantAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
