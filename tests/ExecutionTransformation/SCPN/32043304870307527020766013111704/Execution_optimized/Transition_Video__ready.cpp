/************************************************************

	Transition_Video__ready.cpp  -  generated by CodeGenerator r$Rev$

************************************************************/

#include "Transition_Video__ready.h"

#include "MeasureObj_Execution__thread__pool__in__use.h"

Transition_Video__ready::Transition_Video__ready(int uniqueid, const char* name, NetClass* net, PlaceIdentMap places, string pagePath, double firingWeight, int priority, bool exp, bool takeFirst, bool isInfinite, bool hasLocalGuard) :
	Transition(uniqueid, name, net, places, pagePath, firingWeight, priority, exp, takeFirst, isInfinite, hasLocalGuard)
,
	pool_Place ( *(net->getPlace( &places, "Execution_thread_pool"))),
	nona1_Place ( *(net->getPlace( &places, "Video_executed")))
{
}

Transition_Video__ready::~Transition_Video__ready()
{
}

bool Transition_Video__ready::globalGuard()
{
	return true;
}
void Transition_Video__ready::initGlobalGuards()
{
}

void Transition_Video__ready::moveTokens(TokenList &binding)
{
	TokenList::iterator binding_it = binding.begin();

	SMARTPTR(Token_int) token_pool = UPCAST_MACRO(Token_int)(*binding_it ++);
	pool_Place.removeToken(token_pool);

	{
		// Handle token 1 of 1

		// Generate Token: {}
		{
			SMARTPTR(Token_Data) newToken_0 = NEW_MACRO(Token_Data, Token_Data());
			nona1_Place.addToken(newToken_0);
		}
	}
}

TempBindingList* Transition_Video__ready::generateBindingList()
{
	TokenList* tok;
	TempBindingList* tempBindings =  new TempBindingList();

	const TokenList &pool_tokenList = getPlaceMarking(pool_Place);
	TokenList::const_iterator pool_iterator;

	for (pool_iterator=pool_tokenList.begin(); pool_iterator!=pool_tokenList.end(); ++pool_iterator) {
		SMARTPTR(Token_int) token_pool = UPCAST_MACRO(Token_int)(*pool_iterator);
		
		// Check nulls 
		if (token_pool == 0) {
			continue;
		}
		
		{
			
			// Check nulls 
			
		}

		// All local guards passed:
		tok = new TokenList();
		tok->push_back(UPCAST_MACRO(Token_int)(*pool_iterator));
		tempBindings->push_back(tok);
		return tempBindings;
	}
	return tempBindings;
}

void Transition_Video__ready::log(TokenList &binding)
{
}

double Transition_Video__ready::display(TokenList &binding)
{
	return 0.0;
}

Seconds_T Transition_Video__ready::getFiringDelay(TokenList &binding) const
{
	// Orig Expression: Det(33.333333333)
	// C++  Expression: 33.333333333

	TokenList::iterator binding_it = binding.begin();

	SMARTPTR(Token_int) token_pool = UPCAST_MACRO(Token_int)(*binding_it ++);
	return delay.Det(33.333333333);
}

bool Transition_Video__ready::hasTimeguard() const
{
	return false;
}

Seconds_T Transition_Video__ready::Timeguard(const DateTime& now)
{
	return 0.0;
}

