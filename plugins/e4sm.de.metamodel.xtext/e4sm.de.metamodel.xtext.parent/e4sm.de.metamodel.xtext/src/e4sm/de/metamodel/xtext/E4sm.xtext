// automatically generated by Xtext
grammar e4sm.de.metamodel.xtext.E4sm with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://de.tu-ilmenau/e4sm/core/1.0.0" as core
import "http://de.tu-ilmenau/e4sm/1.0.0"
import "http://de.tu-ilmenau/e4sm/analysis/1.0.0" as analysis
import "http://de.tu-ilmenau/e4sm/execution/1.0.0" as execution

Model returns Model:
	'model'
	name=EString
	'{'
	(imports+=Import ("," imports+=Import)*)?
	('picturesPath' PROPERTY_ASSIGN personsPicturesPath=EString)?
	(types+=TypeSpecification ("," types+=TypeSpecification)*)?
	(parameters+=Parameter ("," parameters+=Parameter)*)?
	(packages+=Package ("," packages+=Package)*)?
	(actors+=Actor ("," actors+=Actor)*)?
	(variants+=Variant ("," variants+=Variant)*)?
	'}';

Import returns Import:
	{Import}
	'import' referencedModel=[Model|STRING] ';';

Actor returns Actor:
	Actor_Impl | Human_Impl | Robot | Person;

ValueSpecification returns core::ValueSpecification:
	LiteralNull | LiteralString | LiteralInteger | LiteralBoolean | LiteralFloat | LiteralDouble | LiteralLong |
	LiteralShort | LiteralByte | LiteralCharacter | LiteralDate;

Component returns Component:
	Component_Impl | MachineLearningComponent | PhysicalComponent_Impl | SoftwareComponent_Impl | Heuristic | Function |
	ExternalDependency | Sensor | Actuator;

Connector returns Connector:
	Connector_Impl | PhysicalConnector | LogicalConnector;

EDataType returns ecore::EDataType:
	EDataType_Impl | EEnum;

EStructuralFeature returns ecore::EStructuralFeature:
	EAttribute | EReference;

EClassifier returns ecore::EClassifier:
	EClass | EDataType_Impl | EEnum;

Pin returns Pin:
	InputPin | OutputPin;

EString returns ecore::EString:
	STRING | ID;

Parameter returns analysis::Parameter:
	'par'
	'{'
	'parameterDefinition' PROPERTY_ASSIGN parameterDefinition=[analysis::ParameterDefinition|EString]
	('appliesOnlyOnVariants' '(' appliesOnlyOnVariants+=[core::Variant|EString] (","
	appliesOnlyOnVariants+=[core::Variant|EString])* ')')?
	('doesNotApplyOnVariants' '(' doesNotApplyOnVariants+=[core::Variant|EString] (","
	doesNotApplyOnVariants+=[core::Variant|EString])* ')')?
	('initialValue' PROPERTY_ASSIGN initialValue=ValueSpecification)?
	('currentValue' PROPERTY_ASSIGN currentValue=ValueSpecification)?
	'}';

Package returns Package:
	'package'
	name=EString
	'{'
	('mainResponsible' PROPERTY_ASSIGN mainResponsible=[Person|EString])?
	('specifiesComponent' PROPERTY_ASSIGN specifiesComponent=[Component|EString])?
	(parameters+=Parameter ("," parameters+=Parameter)*)?
	(components+=Component ("," components+=Component)*)?
	(connectors+=Connector ("," connectors+=Connector)*)?
	(sectors+=Sector ("," sectors+=Sector)*)?
	('subpackages' '{' packages+=Package ("," packages+=Package)* '}')?
	'}';

terminal PROPERTY_ASSIGN:
	':';

Actor_Impl returns Actor:
	{Actor}
	'actor'
	name=EString;

Variant returns core::Variant:
	{core::Variant}
	'variant'
	name=EString;

ParameterDefinition returns analysis::ParameterDefinition:
	{analysis::ParameterDefinition}
	'ParameterDefinition'
	name=EString
	'{'
	('unit' unit=UnitOfMeasurement)?
	// ('type' type=[ecore::EDataType|EString])?
	('parameters' '(' parameters+=[analysis::Parameter|EString] ("," parameters+=[analysis::Parameter|EString])* ')')?
	// ('mustBeDefinedOn' '(' mustBeDefinedOn+=[ecore::EClass|EString] ( "," mustBeDefinedOn+=[ecore::EClass|EString])* ')' )?
	// ('canBeDefinedOn' '(' canBeDefinedOn+=[ecore::EClass|EString] ( "," canBeDefinedOn+=[ecore::EClass|EString])* ')' )?
	// ('shallNotBeDefinedOn' '(' shallNotBeDefinedOn+=[ecore::EClass|EString] ( "," shallNotBeDefinedOn+=[ecore::EClass|EString])* ')' )?
	('defaultValue' defaultValue=ValueSpecification)?
	'}';

EDataType_Impl returns ecore::EDataType:
	{ecore::EDataType}
	'EDataType'
	name=EString
	'{'
	('instanceClassName' instanceClassName=EString)?
	('instanceTypeName' instanceTypeName=EString)?
	('serializable' serializable=EBoolean)?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eTypeParameters' '{' eTypeParameters+=ETypeParameter ("," eTypeParameters+=ETypeParameter)* '}')?
	'}';

enum UnitOfMeasurement returns core::UnitOfMeasurement:
	cm='cm' | m='m' | mm='mm' | percentage='percentage' | s='s' | ms='ms' | minutes='minutes' | hours='hours' |
	mbps='mbps' | none='none';

EClass returns ecore::EClass:
	{ecore::EClass}
	(abstract?='abstract')?
	(interface?='interface')?
	'EClass'
	name=EString
	'{'
	('instanceClassName' instanceClassName=EString)?
	('instanceTypeName' instanceTypeName=EString)?
	('eSuperTypes' '(' eSuperTypes+=[ecore::EClass|EString] ("," eSuperTypes+=[ecore::EClass|EString])* ')')?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eTypeParameters' '{' eTypeParameters+=ETypeParameter ("," eTypeParameters+=ETypeParameter)* '}')?
	('eOperations' '{' eOperations+=EOperation ("," eOperations+=EOperation)* '}')?
	('eStructuralFeatures' '{' eStructuralFeatures+=EStructuralFeature ("," eStructuralFeatures+=EStructuralFeature)*
	'}')?
	('eGenericSuperTypes' '{' eGenericSuperTypes+=EGenericType ("," eGenericSuperTypes+=EGenericType)* '}')?
	'}';

EAnnotation returns ecore::EAnnotation:
	{ecore::EAnnotation}
	'EAnnotation'
	'{'
	('source' source=EString)?
	('references' '(' references+=[ecore::EObject|EString] ("," references+=[ecore::EObject|EString])* ')')?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('details' '{' details+=EStringToStringMapEntry ("," details+=EStringToStringMapEntry)* '}')?
	('contents' '{' contents+=EObject ("," contents+=EObject)* '}')?
	'}';

ETypeParameter returns ecore::ETypeParameter:
	{ecore::ETypeParameter}
	'ETypeParameter'
	name=EString
	'{'
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eBounds' '{' eBounds+=EGenericType ("," eBounds+=EGenericType)* '}')?
	'}';

EBoolean returns ecore::EBoolean:
	'true' | 'false';

EEnum returns ecore::EEnum:
	{ecore::EEnum}
	'EEnum'
	name=EString
	'{'
	('instanceClassName' instanceClassName=EString)?
	('instanceTypeName' instanceTypeName=EString)?
	('serializable' serializable=EBoolean)?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eTypeParameters' '{' eTypeParameters+=ETypeParameter ("," eTypeParameters+=ETypeParameter)* '}')?
	('eLiterals' '{' eLiterals+=EEnumLiteral ("," eLiterals+=EEnumLiteral)* '}')?
	'}';

EStringToStringMapEntry returns ecore::EStringToStringMapEntry:
	{ecore::EStringToStringMapEntry}
	'EStringToStringMapEntry'
	'{'
	('key' key=EString)?
	('value' value=EString)?
	'}';

EObject returns ecore::EObject:
	{ecore::EObject}
	'EObject';

EGenericType returns ecore::EGenericType:
	{ecore::EGenericType}
	'EGenericType'
	'{'
	('eTypeParameter' eTypeParameter=[ecore::ETypeParameter|EString])?
	('eClassifier' eClassifier=[ecore::EClassifier|EString])?
	('eUpperBound' eUpperBound=EGenericType)?
	('eTypeArguments' '{' eTypeArguments+=EGenericType ("," eTypeArguments+=EGenericType)* '}')?
	('eLowerBound' eLowerBound=EGenericType)?
	'}';

EEnumLiteral returns ecore::EEnumLiteral:
	{ecore::EEnumLiteral}
	'EEnumLiteral'
	name=EString
	'{'
	('value' value=EInt)?
	('literal' literal=EString)?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	'}';

EInt returns ecore::EInt:
	'-'? INT;

EOperation returns ecore::EOperation:
	{ecore::EOperation}
	'EOperation'
	name=EString
	'{'
	('ordered' ordered=EBoolean)?
	('unique' unique=EBoolean)?
	('lowerBound' lowerBound=EInt)?
	('upperBound' upperBound=EInt)?
	('eType' eType=[ecore::EClassifier|EString])?
	('eExceptions' '(' eExceptions+=[ecore::EClassifier|EString] ("," eExceptions+=[ecore::EClassifier|EString])* ')')?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eGenericType' eGenericType=EGenericType)?
	('eTypeParameters' '{' eTypeParameters+=ETypeParameter ("," eTypeParameters+=ETypeParameter)* '}')?
	('eParameters' '{' eParameters+=EParameter ("," eParameters+=EParameter)* '}')?
	('eGenericExceptions' '{' eGenericExceptions+=EGenericType ("," eGenericExceptions+=EGenericType)* '}')?
	'}';

EParameter returns ecore::EParameter:
	{ecore::EParameter}
	'EParameter'
	name=EString
	'{'
	('ordered' ordered=EBoolean)?
	('unique' unique=EBoolean)?
	('lowerBound' lowerBound=EInt)?
	('upperBound' upperBound=EInt)?
	('eType' eType=[ecore::EClassifier|EString])?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eGenericType' eGenericType=EGenericType)?
	'}';

EAttribute returns ecore::EAttribute:
	{ecore::EAttribute}
	(volatile?='volatile')?
	(transient?='transient')?
	(unsettable?='unsettable')?
	(derived?='derived')?
	(iD?='iD')?
	'EAttribute'
	name=EString
	'{'
	('ordered' ordered=EBoolean)?
	('unique' unique=EBoolean)?
	('lowerBound' lowerBound=EInt)?
	('upperBound' upperBound=EInt)?
	('changeable' changeable=EBoolean)?
	('defaultValueLiteral' defaultValueLiteral=EString)?
	('eType' eType=[ecore::EClassifier|EString])?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eGenericType' eGenericType=EGenericType)?
	'}';

EReference returns ecore::EReference:
	{ecore::EReference}
	(volatile?='volatile')?
	(transient?='transient')?
	(unsettable?='unsettable')?
	(derived?='derived')?
	(containment?='containment')?
	'EReference'
	name=EString
	'{'
	('ordered' ordered=EBoolean)?
	('unique' unique=EBoolean)?
	('lowerBound' lowerBound=EInt)?
	('upperBound' upperBound=EInt)?
	('changeable' changeable=EBoolean)?
	('defaultValueLiteral' defaultValueLiteral=EString)?
	('resolveProxies' resolveProxies=EBoolean)?
	('eType' eType=[ecore::EClassifier|EString])?
	('eOpposite' eOpposite=[ecore::EReference|EString])?
	('eKeys' '(' eKeys+=[ecore::EAttribute|EString] ("," eKeys+=[ecore::EAttribute|EString])* ')')?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eGenericType' eGenericType=EGenericType)?
	'}';

LiteralNull returns core::LiteralNull:
	{core::LiteralNull}
	'null';

LiteralString returns core::LiteralString:
	{core::LiteralString}
	value=STRING;

//LiteralInteger returns core::LiteralInteger:
//	{core::LiteralInteger}
//	'LiteralInteger'
//	name=EString
//	'{'
//		('value' value=Integer)?
//		// ('type' type=[ecore::EDataType|EString])?
//	'}';
LiteralBoolean returns core::LiteralBoolean:
	{core::LiteralBoolean}
	(value?='true' | 'false');

LiteralFloat returns core::LiteralFloat:
	{core::LiteralFloat}
	'f' INT '.' INT;

LiteralDouble returns core::LiteralDouble:
	{core::LiteralDouble}
	INT '.' INT;

LiteralLong returns core::LiteralLong:
	{core::LiteralLong}
	'LiteralLong'
	name=EString
	'{'
	('value' value=Long)?
	// ('type' type=[ecore::EDataType|EString])?
	'}';

LiteralShort returns core::LiteralShort:
	{core::LiteralShort}
	'LiteralShort'
	name=EString
	'{'
	('value' value=Short)?
	// ('type' type=[ecore::EDataType|EString])?
	'}';

LiteralByte returns core::LiteralByte:
	{core::LiteralByte}
	'LiteralByte'
	name=EString
	'{'
	('value' value=Byte)?
	// ('type' type=[ecore::EDataType|EString])?
	'}';

LiteralCharacter returns core::LiteralCharacter:
	{core::LiteralCharacter}
	'LiteralCharacter'
	name=EString
	'{'
	('value' value=Character)?
	// ('type' type=[ecore::EDataType|EString])?
	'}';

LiteralDate returns core::LiteralDate:
	{core::LiteralDate}
	'LiteralDate'
	name=EString
	'{'
	('value' value=Date)?
	// ('type' type=[ecore::EDataType|EString])?
	'}';

String0 returns core::String:
	'String' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Integer returns core::Integer:
	'Integer' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Boolean returns core::Boolean:
	'Boolean' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Float returns core::Float:
	'Float' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Double returns core::Double:
	'Double' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Long returns core::Long:
	'Long' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Short returns core::Short:
	'Short' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Byte returns core::Byte:
	'Byte' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Character returns core::Character:
	'Character' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Date returns core::Date:
	'Date' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Component_Impl returns Component:
	{Component}
	'component'
	name=EString
	'{'
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	(pins+=Pin ("," pins+=Pin)*)?
	('runs' '{' execution=Execution '}')?
	'}';

Connector_Impl returns Connector:
	'connector'
	name=EString
	source=[Pin|EString] '->' target=[Pin|EString]
	('{'
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	'}')?;

Sector returns Sector:
	{Sector}
	'sector'
	name=EString
	'{'
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('sectors' '{' sectors+=Sector ("," sectors+=Sector)* '}')?
	'}';

Person returns Person:
	'person'
	name=EString
	'{'
	'surname' surname=EString
	('department' department=EString)?
	('pictureFileName' pictureFileName=EString)?
	('responsibleForComponents' '(' responsibleForComponents+=[Component|EString] (","
	responsibleForComponents+=[Component|EString])* ')')?
	'}';

MachineLearningComponent returns MachineLearningComponent:
	{MachineLearningComponent}
	'mlComponent'
	name=EString
	'{'
	(pins+=Pin ("," pins+=Pin)*)?
	('outputUncertainty' outputUncertainty=EDouble)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

PhysicalComponent_Impl returns PhysicalComponent:
	{PhysicalComponent}
	'physicalComponent'
	name=EString
	'{'
	pins+=Pin ("," pins+=Pin)*
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

SoftwareComponent_Impl returns SoftwareComponent:
	{SoftwareComponent}
	'softwareComponent'
	name=EString
	'{'
	(pins+=Pin ("," pins+=Pin)*)?
	('outputUncertainty' outputUncertainty=EDouble)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

Heuristic returns Heuristic:
	{Heuristic}
	'heuristic'
	name=EString
	'{'
	(pins+=Pin ("," pins+=Pin)*)?
	('outputUncertainty' outputUncertainty=EDouble)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

Function returns Function:
	{Function}
	'function'
	name=EString
	'{'
	(pins+=Pin ("," pins+=Pin)*)?
	('outputUncertainty' outputUncertainty=EDouble)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

ExternalDependency returns ExternalDependency:
	{ExternalDependency}
	'externalDependency'
	name=EString
	'{'
	(pins+=Pin ("," pins+=Pin)*)?
	('outputUncertainty' outputUncertainty=EDouble)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

Sensor returns Sensor:
	'sensor'
	name=EString
	'{'
	(pins+=Pin ("," pins+=Pin)*)?
	//'timeFunction' timeFunction=TimeFunction
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

Actuator returns Actuator:
	{Actuator}
	'actuator'
	name=EString
	'{'
	(pins+=Pin ("," pins+=Pin)*)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

enum RaceSemantic returns RaceSemantic:
	FCFS='FCFS' | DUPLICATE='DUPLICATE' | MERGE='MERGE' | MERGE_AND_DUPLICATE='MERGE_AND_DUPLICATE';

InputPin returns InputPin:
	{InputPin}
	'in' (stream?='stream')?
	(type=[core::TypeSpecification])?
	name=EString // (':' type=[ecore::EDataType|EString])?
	('{'
	('raceSemantic' raceSemantic=RaceSemantic)?
	('queueType' queueType=QueueType)?
	// ('outgoingConnectors' '(' outgoingConnectors+=[Connector|EString] ( "," outgoingConnectors+=[Connector|EString])* ')' )?
	// ('incomingConnectors' '(' incomingConnectors+=[Connector|EString] ( "," incomingConnectors+=[Connector|EString])* ')' )?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	'}')?;

OutputPin returns OutputPin:
	{OutputPin}
	'out' (stream?='stream')?
	(type=[core::TypeSpecification])?
	name=EString // (':' type=[ecore::EDataType])?
	('{'
	('raceSemantic' raceSemantic=RaceSemantic)?
	// ('outgoingConnectors' '(' outgoingConnectors+=[Connector|EString] ( "," outgoingConnectors+=[Connector|EString])* ')' )?
	// ('incomingConnectors' '(' incomingConnectors+=[Connector|EString] ( "," incomingConnectors+=[Connector|EString])* ')' )?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	'}')?;

enum QueueType returns QueueType:
	FIFO='FIFO' | LIFO='LIFO' | RANDOM='RANDOM' | LATEST_ONLY='LATEST_ONLY' | STORE='STORE';

EDouble returns ecore::EDouble:
	'-'? INT? '.' INT (('E' | 'e') '-'? INT)?;

TimeFunction returns TimeFunction:
	'TimeFunction' /* TODO: implement this rule and an appropriate IValueConverter */ ;

PhysicalConnector returns PhysicalConnector:
	'physicalConnector'
	name=EString
	source=[Pin|EString] '->'
	target=[Pin|EString]
	('{'
	('minSpeed' minSpeed=Connectionspeed)?
	('maxSpeed' maxSpeed=Connectionspeed)?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	'}')?;

LogicalConnector returns LogicalConnector:
	'logicalConnector'
	'source' source=[Pin|EString]
	'target' target=[Pin|EString]
	name=EString
	('{'
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	'}')?;

Connectionspeed returns Connectionspeed:
	'Connectionspeed' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Human_Impl returns Human:
	{Human}
	'human'
	name=EString;

Robot returns Robot:
	{Robot}
	'robot'
	name=EString;

/* EXECUTION */
Execution returns execution::Execution:
	{execution::Execution}
	elements+=Elements+;

Elements returns execution::Element:
	Flow | ConnectableNode | Addition | Variable | Const | Assignment;

ConnectableNode returns execution::ConnectableNode:
	FlowFinal | ForkNode | MergeNode // TODO
;

Flow returns execution::Flow:
	source=[execution::ConnectableNode] '->' target=[execution::ConnectableNode] ('takes'
	timeFunction=ComplexTimefunction)?';';

ComplexTimefunction returns execution::TimeFunction: //TODO, allow operations
	ExeTimeFunction;

ExeTimeFunction returns execution::TimeFunction:
	{execution::TimeFunction}
	function=TimeFunctions '(' par1=EDouble (',' par2=EDouble)? ')';

enum TimeFunctions returns execution::TimeFunctions:
	Det='Det' | Exp='Exp' | Uni='Uni' | DUni='DUni' | Norm='Norm' | LogNorm='LogNorm' | Wei='Wei' | DUni='Triang';

FlowFinal returns execution::FlowFinal:
	{execution::FlowFinal}
	source=[execution::ConnectableNode] '->' 'discard' ';';

ForkNode returns execution::ForkNode:
	'fork' source=[execution::ConnectableNode] '{'
	targets+=[execution::ConnectableNode] ("," targets+=[execution::ConnectableNode])*
	('takes' timeFunction=ComplexTimefunction)?
	'}';

MergeNode returns execution::MergeNode:
	'join' '{'
	sources+=[execution::ConnectableNode] ("," sources+=[execution::ConnectableNode])*
	('takes' timeFunction=ComplexTimefunction)?
	'}' 'to' target=[execution::ConnectableNode];

Expression returns execution::Expression:
	Addition;

//UnaryExpression returns execution::Expression:
//	ValueSpecification | VariableRef;

Addition returns execution::Expression:
	{execution::Addition}
	left=Multiplication ({execution::Addition.left=current}
	(addition?='+' | subtraction?='-')
	right=Multiplication)*;

Multiplication returns execution::Expression:
	{execution::Multiplication}
	left=Primary ({execution::Multiplication.left=current}
	(multiplication?='*' | division?='/')
	right=Primary)*;
	
AssignableElement returns execution::AssignableElement:
	Variable | OutputPin
;

Primary returns execution::Expression:
	ValueSpecification | VariableRef |
	'(' Addition ')';
	
LiteralInteger returns core::LiteralInteger:
	value=INT;

Variable returns execution::Variable:
	'var' name=ID ('=' expression=Expression)? ';';

Const returns execution::Const:
	'const' name=ID ('=' expression=Expression)? ';';

Assignment returns execution::Assignment:
 	target=AssignableElementReference '=' expression=Expression ';'
;

AssignableElementReference returns execution::AssignableElementReference:
	ref=[execution::AssignableElement]
;


VariableRef returns execution::VariableRef:
	{execution::VariableRef}
	variable=[execution::Variable];

/* TYPES */
TypeSpecification returns core::TypeSpecification:
	{core::TypeSpecification}
	(abstract?='abstract')? 'type' name=ID ('extends' superType=[core::TypeSpecification])? '{'
	(attributes+=AttributeSpecification (',' attributes+=AttributeSpecification)*)?'}';

AttributeSpecification returns core::AttributeSpecification:
	IntegerAttribute | DoubleAttribute | StringAttribute | BooleanAttribute | ClassAttribute;

IntegerAttribute returns core::IntegerAttribute:
	{core::IntegerAttribute}
	'int' name=ID ('=' defaultValue=EInt)?;

DoubleAttribute returns core::DoubleAttribute:
	{core::DoubleAttribute}
	'double' (array?='[' ']')? name=ID ('=' defaultValue=EDouble)?;

StringAttribute returns core::StringAttribute:
	{core::StringAttribute}
	'string' (array?='[' ']')? name=ID ('=' defaultValue=EString)?;

BooleanAttribute returns core::BooleanAttribute:
	{core::BooleanAttribute}
	'boolean' (array?='[' ']')? name=ID ('=' defaultValue=EBoolean)?;

ClassAttribute returns core::ClassAttribute:
	{core::ClassAttribute}
	type=[core::TypeSpecification] (array?='[' ']')? name=ID;
