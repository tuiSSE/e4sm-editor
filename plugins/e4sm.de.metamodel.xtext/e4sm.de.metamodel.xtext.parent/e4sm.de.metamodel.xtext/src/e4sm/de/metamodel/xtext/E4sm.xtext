// automatically generated by Xtext
grammar e4sm.de.metamodel.xtext.E4sm with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://de.tu-ilmenau/e4sm/core/1.0.0" as core
import "http://de.tu-ilmenau/e4sm/1.0.0"
import "http://de.tu-ilmenau/e4sm/analysis/1.0.0" as analysis
import "http://de.tu-ilmenau/e4sm/execution/1.0.0" as execution

Model returns Model:
	'model'
	name=EString
	'{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	(imports+=Import ("," imports+=Import)*)?
	('picturesPath' PROPERTY_ASSIGN personsPicturesPath=EString)?
	(types+=TypeSpecification ("," types+=TypeSpecification)*)?
	(parameters+=Parameter ("," parameters+=Parameter)*)?
	(packages+=Package ("," packages+=Package)*)?
	(actors+=Actor ("," actors+=Actor)*)?
	(variants+=Variant ("," variants+=Variant)*)?
	(classificationClasses+=ClassificationClass ("," classificationClasses+=ClassificationClass)*)?
	(environments+=Environment ("," environments+=Environment)*)?
	'}';

ClassificationClass returns ClassificationClass:
	{ClassificationClass}
	'cl' name=EString;

ClassificationClassDistribution returns ClassificationClassDistribution:
	{ClassificationClassDistribution}
	classificationClass=[ClassificationClass] probability=EDouble;

Environment returns Environment:
	{Environment}
	'environment' name=EString
	'{'
	(classificationClasses+=ClassificationClassDistribution ("," classificationClasses+=ClassificationClassDistribution)
	*)?
	'}';

ConfusionMatrix returns ConfusionMatrix:
	BinaryConfusionMatrix | MulticlassConfusionMatrix;

BinaryConfusionMatrix returns BinaryConfusionMatrix:
	{BinaryConfusionMatrix}
	'confusion' 'matrix' name=EString
	('with' 'positive' positiveClass=[ClassificationClass|EString] (',' 'negative'
	negativeClass=[ClassificationClass|EString])?)?
	'{'
	'TP' PROPERTY_ASSIGN tp=EInt ',' 'FN' PROPERTY_ASSIGN fn=EInt
	',' 'FP' PROPERTY_ASSIGN fp=EInt ',' 'TN' PROPERTY_ASSIGN tn=EInt
	'}';

MulticlassConfusionMatrix returns MulticlassConfusionMatrix:
	{MulticlassConfusionMatrix}
	'confusion' 'matrix' name=EString
	'{'
	(entries+=ConfusionMatrixEntry ("," entries+=ConfusionMatrixEntry)*)?
	'}';

ConfusionMatrixEntry returns ConfusionMatrixEntry:
	{ConfusionMatrixEntry}
	truth=[ClassificationClass|EString] predicted=[ClassificationClass|EString] PROPERTY_ASSIGN value=EInt;

Import returns Import:
	{Import}
	'import' referencedModel=[Model|STRING] ';';

Actor returns Actor:
	Actor_Impl | Human_Impl | Robot | Person;

ValueSpecification returns core::ValueSpecification:
	LiteralNull | LiteralString | LiteralInteger | LiteralBoolean | LiteralFloat | LiteralDouble | LiteralLong |
	LiteralShort | LiteralByte | LiteralCharacter | LiteralDate;

Component returns Component:
	Component_Impl | MachineLearningComponent | ClassificationComponent | PhysicalComponent_Impl |
	SoftwareComponent_Impl | Heuristic | Function |
	ExternalDependency | Sensor | Actuator;

ClassificationComponent returns ClassificationComponent:
	BinaryClassificationComponent | MulticlassClassificationComponent;

Connector returns Connector:
	Connector_Impl | PhysicalConnector | LogicalConnector;

EDataType returns ecore::EDataType:
	EDataType_Impl | EEnum;

EStructuralFeature returns ecore::EStructuralFeature:
	EAttribute | EReference;

EClassifier returns ecore::EClassifier:
	EClass | EDataType_Impl | EEnum;

DataStore returns DataStore:
	{DataStore}
	'datastore'
	(type=[core::TypeSpecification])?
	name=EString // (':' type=[ecore::EDataType|EString])?
	('{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	'}')?;

DataNode returns DataNode:
	Pin | DataStore;

Pin returns Pin:
	InputPin | OutputPin;

EString returns ecore::EString:
	STRING | ID;

Parameter returns analysis::Parameter:
	{analysis::Parameter}
	'par' name=EString  (':=' initialValue=ValueSpecification)?
	('{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('parameterDefinition' PROPERTY_ASSIGN parameterDefinition=[analysis::ParameterDefinition|EString])?
	('appliesOnlyOnVariants' '(' appliesOnlyOnVariants+=[core::Variant|EString] (","
	appliesOnlyOnVariants+=[core::Variant|EString])* ')')?
	('doesNotApplyOnVariants' '(' doesNotApplyOnVariants+=[core::Variant|EString] (","
	doesNotApplyOnVariants+=[core::Variant|EString])* ')')?
	('currentValue' PROPERTY_ASSIGN currentValue=ValueSpecification)?
	'}')?;

Package returns Package:
	'package'
	name=EString
	'{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('simulationDuration' PROPERTY_ASSIGN simulationDuration=EInt)?
	('mainResponsible' PROPERTY_ASSIGN mainResponsible=[Person|EString])?
	('specifiesComponent' PROPERTY_ASSIGN specifiesComponent=[Component|EString])?
	('processingUnits' PROPERTY_ASSIGN processingUnits=EInt)?
	(parameters+=Parameter ("," parameters+=Parameter)*)?
	(components+=Component ("," components+=Component)*)?
	(connectors+=Connector ("," connectors+=Connector)*)?
	(datastores+=DataStore ("," datastores+=DataStore)*)?
	(sectors+=Sector ("," sectors+=Sector)*)?
	('subPackages' '{' packages+=Package ("," packages+=Package)* '}')?
	'}';

terminal PROPERTY_ASSIGN:
	':';

Actor_Impl returns Actor:
	{Actor}
	'actor'
	name=EString
	('{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	'}')?;

Variant returns core::Variant:
	{core::Variant}
	'variant'
	name=EString
	('{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	'}')?
;
ParameterDefinition returns analysis::ParameterDefinition:
	{analysis::ParameterDefinition}
	'ParameterDefinition'
	name=EString
	'{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('unit' unit=UnitOfMeasurement)?
	// ('type' type=[ecore::EDataType|EString])?
	('parameters' '(' parameters+=[analysis::Parameter|EString] ("," parameters+=[analysis::Parameter|EString])* ')')?
	// ('mustBeDefinedOn' '(' mustBeDefinedOn+=[ecore::EClass|EString] ( "," mustBeDefinedOn+=[ecore::EClass|EString])* ')' )?
	// ('canBeDefinedOn' '(' canBeDefinedOn+=[ecore::EClass|EString] ( "," canBeDefinedOn+=[ecore::EClass|EString])* ')' )?
	// ('shallNotBeDefinedOn' '(' shallNotBeDefinedOn+=[ecore::EClass|EString] ( "," shallNotBeDefinedOn+=[ecore::EClass|EString])* ')' )?
	('defaultValue' defaultValue=ValueSpecification)?
	'}';

EDataType_Impl returns ecore::EDataType:
	{ecore::EDataType}
	'EDataType'
	name=EString
	'{'
	('instanceClassName' instanceClassName=EString)?
	('instanceTypeName' instanceTypeName=EString)?
	('serializable' serializable=EBoolean)?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eTypeParameters' '{' eTypeParameters+=ETypeParameter ("," eTypeParameters+=ETypeParameter)* '}')?
	'}';

enum UnitOfMeasurement returns core::UnitOfMeasurement:
	cm='cm' | m='m' | mm='mm' | percentage='percentage' | s='s' | ms='ms' | minutes='minutes' | hours='hours' |
	mbps='mbps' | none='none';

EClass returns ecore::EClass:
	{ecore::EClass}
	(abstract?='abstract')?
	(interface?='interface')?
	'EClass'
	name=EString
	'{'
	('instanceClassName' instanceClassName=EString)?
	('instanceTypeName' instanceTypeName=EString)?
	('eSuperTypes' '(' eSuperTypes+=[ecore::EClass|EString] ("," eSuperTypes+=[ecore::EClass|EString])* ')')?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eTypeParameters' '{' eTypeParameters+=ETypeParameter ("," eTypeParameters+=ETypeParameter)* '}')?
	('eOperations' '{' eOperations+=EOperation ("," eOperations+=EOperation)* '}')?
	('eStructuralFeatures' '{' eStructuralFeatures+=EStructuralFeature ("," eStructuralFeatures+=EStructuralFeature)*
	'}')?
	('eGenericSuperTypes' '{' eGenericSuperTypes+=EGenericType ("," eGenericSuperTypes+=EGenericType)* '}')?
	'}';

EAnnotation returns ecore::EAnnotation:
	{ecore::EAnnotation}
	'EAnnotation'
	'{'
	('source' source=EString)?
	('references' '(' references+=[ecore::EObject|EString] ("," references+=[ecore::EObject|EString])* ')')?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('details' '{' details+=EStringToStringMapEntry ("," details+=EStringToStringMapEntry)* '}')?
	('contents' '{' contents+=EObject ("," contents+=EObject)* '}')?
	'}';

ETypeParameter returns ecore::ETypeParameter:
	{ecore::ETypeParameter}
	'ETypeParameter'
	name=EString
	'{'
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eBounds' '{' eBounds+=EGenericType ("," eBounds+=EGenericType)* '}')?
	'}';

EBoolean returns ecore::EBoolean:
	'true' | 'false';

EEnum returns ecore::EEnum:
	{ecore::EEnum}
	'EEnum'
	name=EString
	'{'
	('instanceClassName' instanceClassName=EString)?
	('instanceTypeName' instanceTypeName=EString)?
	('serializable' serializable=EBoolean)?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eTypeParameters' '{' eTypeParameters+=ETypeParameter ("," eTypeParameters+=ETypeParameter)* '}')?
	('eLiterals' '{' eLiterals+=EEnumLiteral ("," eLiterals+=EEnumLiteral)* '}')?
	'}';

EStringToStringMapEntry returns ecore::EStringToStringMapEntry:
	{ecore::EStringToStringMapEntry}
	'EStringToStringMapEntry'
	'{'
	('key' key=EString)?
	('value' value=EString)?
	'}';

EObject returns ecore::EObject:
	{ecore::EObject}
	'EObject';

EGenericType returns ecore::EGenericType:
	{ecore::EGenericType}
	'EGenericType'
	'{'
	('eTypeParameter' eTypeParameter=[ecore::ETypeParameter|EString])?
	('eClassifier' eClassifier=[ecore::EClassifier|EString])?
	('eUpperBound' eUpperBound=EGenericType)?
	('eTypeArguments' '{' eTypeArguments+=EGenericType ("," eTypeArguments+=EGenericType)* '}')?
	('eLowerBound' eLowerBound=EGenericType)?
	'}';

EEnumLiteral returns ecore::EEnumLiteral:
	{ecore::EEnumLiteral}
	'EEnumLiteral'
	name=EString
	'{'
	('value' value=EInt)?
	('literal' literal=EString)?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	'}';

EOperation returns ecore::EOperation:
	{ecore::EOperation}
	'EOperation'
	name=EString
	'{'
	('ordered' ordered=EBoolean)?
	('unique' unique=EBoolean)?
	('lowerBound' lowerBound=EInt)?
	('upperBound' upperBound=EInt)?
	('eType' eType=[ecore::EClassifier|EString])?
	('eExceptions' '(' eExceptions+=[ecore::EClassifier|EString] ("," eExceptions+=[ecore::EClassifier|EString])* ')')?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eGenericType' eGenericType=EGenericType)?
	('eTypeParameters' '{' eTypeParameters+=ETypeParameter ("," eTypeParameters+=ETypeParameter)* '}')?
	('eParameters' '{' eParameters+=EParameter ("," eParameters+=EParameter)* '}')?
	('eGenericExceptions' '{' eGenericExceptions+=EGenericType ("," eGenericExceptions+=EGenericType)* '}')?
	'}';

EParameter returns ecore::EParameter:
	{ecore::EParameter}
	'EParameter'
	name=EString
	'{'
	('ordered' ordered=EBoolean)?
	('unique' unique=EBoolean)?
	('lowerBound' lowerBound=EInt)?
	('upperBound' upperBound=EInt)?
	('eType' eType=[ecore::EClassifier|EString])?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eGenericType' eGenericType=EGenericType)?
	'}';

EAttribute returns ecore::EAttribute:
	{ecore::EAttribute}
	(volatile?='volatile')?
	(transient?='transient')?
	(unsettable?='unsettable')?
	(derived?='derived')?
	(iD?='iD')?
	'EAttribute'
	name=EString
	'{'
	('ordered' ordered=EBoolean)?
	('unique' unique=EBoolean)?
	('lowerBound' lowerBound=EInt)?
	('upperBound' upperBound=EInt)?
	('changeable' changeable=EBoolean)?
	('defaultValueLiteral' defaultValueLiteral=EString)?
	('eType' eType=[ecore::EClassifier|EString])?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eGenericType' eGenericType=EGenericType)?
	'}';

EReference returns ecore::EReference:
	{ecore::EReference}
	(volatile?='volatile')?
	(transient?='transient')?
	(unsettable?='unsettable')?
	(derived?='derived')?
	(containment?='containment')?
	'EReference'
	name=EString
	'{'
	('ordered' ordered=EBoolean)?
	('unique' unique=EBoolean)?
	('lowerBound' lowerBound=EInt)?
	('upperBound' upperBound=EInt)?
	('changeable' changeable=EBoolean)?
	('defaultValueLiteral' defaultValueLiteral=EString)?
	('resolveProxies' resolveProxies=EBoolean)?
	('eType' eType=[ecore::EClassifier|EString])?
	('eOpposite' eOpposite=[ecore::EReference|EString])?
	('eKeys' '(' eKeys+=[ecore::EAttribute|EString] ("," eKeys+=[ecore::EAttribute|EString])* ')')?
	('eAnnotations' '{' eAnnotations+=EAnnotation ("," eAnnotations+=EAnnotation)* '}')?
	('eGenericType' eGenericType=EGenericType)?
	'}';

LiteralNull returns core::LiteralNull:
	{core::LiteralNull}
	'null';

LiteralString returns core::LiteralString:
	{core::LiteralString}
	value=STRING;

LiteralBoolean returns core::LiteralBoolean:
	{core::LiteralBoolean}
	(value?='true' | 'false');

LiteralFloat returns core::LiteralFloat:
	{core::LiteralFloat}
	value=Float;

LiteralDouble returns core::LiteralDouble:
	{core::LiteralDouble}
	value=EDouble;

LiteralLong returns core::LiteralLong:
	{core::LiteralLong}
	value=Long;

LiteralShort returns core::LiteralShort:
	{core::LiteralShort}
	'LiteralShort'
	name=EString
	'{'
	('value' value=Short)?
	// ('type' type=[ecore::EDataType|EString])?
	'}';

LiteralByte returns core::LiteralByte:
	{core::LiteralByte}
	'LiteralByte'
	name=EString
	'{'
	('value' value=Byte)?
	// ('type' type=[ecore::EDataType|EString])?
	'}';

LiteralCharacter returns core::LiteralCharacter:
	{core::LiteralCharacter}
	'LiteralCharacter'
	name=EString
	'{'
	('value' value=Character)?
	// ('type' type=[ecore::EDataType|EString])?
	'}';

LiteralDate returns core::LiteralDate:
	{core::LiteralDate}
	'LiteralDate'
	name=EString
	'{'
	('value' value=Date)?
	// ('type' type=[ecore::EDataType|EString])?
	'}';

Float returns core::Float:
	'f' INT '.' INT;

Long returns core::Long:
	'l' INT;

// 'Long' /* TODO: implement this rule and an appropriate IValueConverter */ ;
Short returns core::Short:
	'Short' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Byte returns core::Byte:
	'Byte' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Character returns core::Character:
	'Character' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Date returns core::Date:
	'Date' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Component_Impl returns Component:
	{Component}
	'component'
	name=EString
	'{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

Connector_Impl returns Connector:
	'connector'
	name=EString
	source=[Pin|EString] '->' target=[Pin|EString]
	('{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('takes' timeFunction=ComplexTimefunction)?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	'}')?;

Sector returns Sector:
	{Sector}
	'sector'
	name=EString
	'{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('sectors' '{' sectors+=Sector ("," sectors+=Sector)* '}')?
	'}';

Person returns Person:
	'person'
	(name=EString | surname=EString ',' name=EString)
	'{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('department' department=EString)?
	('pictureFileName' pictureFileName=EString)?
	// ('responsibleForComponents' '(' responsibleForComponents+=[Component|EString] (","
	// responsibleForComponents+=[Component|EString])* ')')?
	'}';

MulticlassClassificationComponent returns MulticlassClassificationComponent:
	{MulticlassClassificationComponent}
	'multiclassClassificationComponent'
	name=EString
	'{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	('confusionMatrixes' '{' confusionMatrixes+=MulticlassConfusionMatrix (","
	confusionMatrixes+=MulticlassConfusionMatrix)* '}')?
	'}';

BinaryClassificationComponent returns BinaryClassificationComponent:
	{BinaryClassificationComponent}
	'binaryClassificationComponent'
	name=EString
	'{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	('confusionMatrixes' '{' confusionMatrixes+=BinaryConfusionMatrix ("," confusionMatrixes+=BinaryConfusionMatrix)*
	'}')?
	'}';

MachineLearningComponent returns MachineLearningComponent:
	{MachineLearningComponent}
	'mlComponent'
	name=EString
	'{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

PhysicalComponent_Impl returns PhysicalComponent:
	{PhysicalComponent}
	'physicalComponent'
	name=EString
	'{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

SoftwareComponent_Impl returns SoftwareComponent:
	{SoftwareComponent}
	'softwareComponent'
	name=EString
	'{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

Heuristic returns Heuristic:
	{Heuristic}
	'heuristic'
	name=EString
	'{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

Function returns Function:
	{Function}
	'function'
	name=EString
	'{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

ExternalDependency returns ExternalDependency:
	{ExternalDependency}
	'externalDependency'
	name=EString
	'{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('synchronous' synchronous=EBoolean)?
	('numberOfServers' numberOfServers=EInt)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

Sensor returns Sensor:
	'sensor'
	name=EString
	'{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	// 'timeFunction' timeFunction=TimeFunction
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

Actuator returns Actuator:
	{Actuator}
	'actuator'
	name=EString
	'{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('firingStrategy' firingStrategy=ComponentFiringStrategy)?
	('takes' timeFunction=ComplexTimefunction)?
	(pins+=Pin ("," pins+=Pin)*)?
	('mainResponsible' mainResponsible=[Person|EString])?
	('specifiedInPackage' specifiedInPackage=[Package|EString])?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	('components' '{' components+=Component ("," components+=Component)* '}')?
	('datastores' '{' datastores+=DataStore ("," datastores+=DataStore)* '}')?
	('runs' '{' execution=Execution '}')?
	'}';

enum RaceSemantic returns RaceSemantic:
	FCFS='FCFS' | DUPLICATE='DUPLICATE' | MERGE='MERGE' | MERGE_AND_DUPLICATE='MERGE_AND_DUPLICATE';

enum ComponentFiringStrategy returns ComponentFiringStrategy:
	AND='AND' | AND='&&' | OR='OR' | OR='||';

InputPin returns InputPin:
	{InputPin}
	(optional?='optional')? 'in' (stream?='stream')?
	(type=[core::TypeSpecification])?
	name=EString // (':' type=[ecore::EDataType|EString])?
	('{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('collects' collect=EInt)?
	('raceSemantic' raceSemantic=RaceSemantic)?
	('queueType' queueType=QueueType)?
	// ('outgoingConnectors' '(' outgoingConnectors+=[Connector|EString] ( "," outgoingConnectors+=[Connector|EString])* ')' )?
	// ('incomingConnectors' '(' incomingConnectors+=[Connector|EString] ( "," incomingConnectors+=[Connector|EString])* ')' )?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	'}')?;

OutputPin returns OutputPin:
	{OutputPin}
	'out' (stream?='stream')?
	(type=[core::TypeSpecification])?
	name=EString // (':' type=[ecore::EDataType])?
	('{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('amplifies' amplify=EInt)?
	('outputUncertainty' outputUncertainty=EDouble)?
	('raceSemantic' raceSemantic=RaceSemantic)?
	('generates' tokenSpecification=TokenSpecification)?
	// ('outgoingConnectors' '(' outgoingConnectors+=[Connector|EString] ( "," outgoingConnectors+=[Connector|EString])* ')' )?
	// ('incomingConnectors' '(' incomingConnectors+=[Connector|EString] ( "," incomingConnectors+=[Connector|EString])* ')' )?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	'}')? ('=' outputExpression=Expression)?;

enum QueueType returns QueueType:
	FIFO='FIFO' | LIFO='LIFO' | RANDOM='RANDOM' | LATEST_ONLY='LATEST_ONLY' | STORE='STORE';

EDouble returns ecore::EDouble:
	DOUBLE;

terminal DOUBLE returns ecore::EDouble :
	'-'? INT? '.' INT (('E' | 'e') '-'? INT)?
;

EInt returns ecore::EInt:
	POSSIBLY_NEGATIVE_INT
;

terminal POSSIBLY_NEGATIVE_INT returns ecore::EInt:
	'-'? INT;
	
TokenSpecification returns TokenSpecification:
	{TokenSpecification}
	inputSize += Set 
;

Set returns Set:
	{Set}
	'set' '{'values+=SetValue (values+=SetValue)* '}'
;

SetValue returns SetValue:
	{SetValue}
	'value' PROPERTY_ASSIGN value=EString ('prob' PROPERTY_ASSIGN probability=EDouble & ('size' PROPERTY_ASSIGN size=EDouble)?)';'
;

PhysicalConnector returns PhysicalConnector:
	'physicalConnector'
	name=EString
	source=[Pin|EString] '->' target=[Pin|EString]
	('{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('minSpeed' minSpeed=Connectionspeed)?
	('maxSpeed' maxSpeed=Connectionspeed)?
	('takes' timeFunction=ComplexTimefunction)?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	'}')?;

LogicalConnector returns LogicalConnector:
	'logicalConnector'
	name=EString
	source=[Pin|EString] '->' target=[Pin|EString]
	('{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	('takes' timeFunction=ComplexTimefunction)?
	('parameters' '{' parameters+=Parameter ("," parameters+=Parameter)* '}')?
	'}')?;

Connectionspeed returns Connectionspeed:
	'Connectionspeed' /* TODO: implement this rule and an appropriate IValueConverter */ ;

Human_Impl returns Human:
	{Human}
	'human' name=EString
	('{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	'}')?;

Robot returns Robot:
	{Robot}
	'robot' name=EString
	('{'
	('doc' PROPERTY_ASSIGN documentation=EString)?
	'}')?;

/* EXECUTION */
Execution returns execution::Execution:
	{execution::Execution}
	elements+=Elements+;

Elements returns execution::ExecutionElement:
	Flow | ConnectableNode | Addition | ReferenceableItem | Assignment;

ConnectableNode returns execution::ConnectableNode:
	FlowFinal | ForkNode | MergeNode // TODO
;

Flow returns execution::Flow:
	source=[execution::ConnectableNode] '->' target=[execution::ConnectableNode] ('takes'
	timeFunction=ComplexTimefunction)?';';

ComplexTimefunction returns execution::TimeFunction: //TODO, allow operations
	ExeTimeFunction;

ExeTimeFunction returns execution::TimeFunction:
	{execution::TimeFunction}
	// TODO: this should also be able to accept integer values.
	// Placing EDouble|EInt here makes XText stop working
	function=TimeFunctions '(' par1=Expression (',' par2=Expression)? ')';

enum TimeFunctions returns execution::TimeFunctions:
	Det='Det' | Exp='Exp' | Uni='Uni' | DUni='DUni' | Norm='Norm' | LogNorm='LogNorm' | Wei='Wei' | DUni='Triang';

FlowFinal returns execution::FlowFinal:
	{execution::FlowFinal}
	source=[execution::ConnectableNode] '->' 'discard' ';';

ForkNode returns execution::ForkNode:
	'fork' source=[execution::ConnectableNode] '{'
	targets+=[execution::ConnectableNode] ("," targets+=[execution::ConnectableNode])*
	('takes' timeFunction=ComplexTimefunction)?
	'}';

MergeNode returns execution::MergeNode:
	'join' '{'
	sources+=[execution::ConnectableNode] ("," sources+=[execution::ConnectableNode])*
	('takes' timeFunction=ComplexTimefunction)?
	'}' 'to' target=[execution::ConnectableNode];

Expression returns execution::Expression:
	Addition;

Addition returns execution::Expression:
	{execution::Addition}
	left=Multiplication ({execution::Addition.left=current}
	(addition?='+' | subtraction?='-')
	right=Multiplication)*
;

Multiplication returns execution::Expression:
	{execution::Multiplication}
	left=Exponentiation ({execution::Multiplication.left=current}
	(multiplication?='*' | division?='/')
	right=Exponentiation)*
;
	
Exponentiation returns execution::Exponentiation: 
	{execution::Exponentiation}
	left=Primary ({execution::Exponentiation.left=current}
	'^'
	right = (LiteralInteger | LiteralBoolean | LiteralFloat | LiteralDouble | LiteralLong |	LiteralShort | LiteralByte))*
;


AssignableElement returns execution::AssignableElement:
	Variable | OutputPin;

Primary returns execution::Expression:
	ParameterReference | ValueSpecification | VariableRef | InputPinAttributeReference | InputPinReference |
	'(' Addition ')';

LiteralInteger returns core::LiteralInteger:
	value=EInt;

ReferenceableItem returns execution::ReferenceableItem:
	Variable | Const
;

ParameterReference returns execution::ParameterReference: 
	{execution::ParameterReference}
	'@'parameter=[analysis::Parameter]
;



InputPinReference returns execution::InputPinReference:
	{execution::InputPinReference}
	'$'inputPin=[InputPin]
;

InputPinAttributeReference returns execution::InputPinAttributeReference:
	{execution::InputPinAttributeReference}
	'$'inputPin=[InputPin]'.'attribute=[core::AttributeSpecification]
;



Variable returns execution::Variable:
	'var' name=ID ('=' expression=Expression)? ';';

Const returns execution::Const:
	'const' name=ID ('=' expression=Expression)? ';';

Assignment returns execution::Assignment:
	target=AssignableElementReference '=' expression=Expression ';';

AssignableElementReference returns execution::AssignableElementReference:
	ref=[execution::AssignableElement];

VariableRef returns execution::VariableRef:
	{execution::VariableRef}
	variable=[execution::ReferenceableItem];

/* TYPES */
TypeSpecification returns core::TypeSpecification:
	{core::TypeSpecification}
	(abstract?='abstract')? 'type' name=ID ('extends' superType=[core::TypeSpecification])? '{'
	(attributes+=AttributeSpecification (',' attributes+=AttributeSpecification)*)?'}';

AttributeSpecification returns core::AttributeSpecification:
	IntegerAttribute | DoubleAttribute | StringAttribute | BooleanAttribute | ClassAttribute;

IntegerAttribute returns core::IntegerAttribute:
	{core::IntegerAttribute}
	'int' (array?='[' ']')? name=ID ('=' defaultValue=EInt)?;

DoubleAttribute returns core::DoubleAttribute:
	{core::DoubleAttribute}
	'double' (array?='[' ']')? name=ID ('=' defaultValue=EDouble)?;

StringAttribute returns core::StringAttribute:
	{core::StringAttribute}
	'string' (array?='[' ']')? name=ID ('=' defaultValue=EString)?;

BooleanAttribute returns core::BooleanAttribute:
	{core::BooleanAttribute}
	'boolean' (array?='[' ']')? name=ID ('=' defaultValue=EBoolean)?;

ClassAttribute returns core::ClassAttribute:
	{core::ClassAttribute}
	type=[core::TypeSpecification] (array?='[' ']')? name=ID;