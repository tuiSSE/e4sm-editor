/*
 * generated by Xtext 2.26.0
 */
package e4sm.de.metamodel.xtext.tests

import com.google.inject.Inject
import e4sm.de.metamodel.e4sm.Model
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import e4sm.de.metamodel.e4sm.ComponentFiringStrategy
import org.eclipse.xtext.testing.XtextRunner
import org.junit.runner.RunWith
import org.eclipse.xtext.serializer.impl.Serializer
import e4sm.de.metamodel.e4sm.e4smFactory
import e4sm.de.metamodel.e4sm.e4smPackage
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import java.util.Map
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl
import e4sm.de.metamodel.xtext.E4smStandaloneSetup

@RunWith(XtextRunner)
@ExtendWith(InjectionExtension)
@InjectWith(E4smInjectorProvider)
class E4smParsingTest {
	@Inject
	ParseHelper<Model> parseHelper

	@Inject Serializer serializer

	static val toBeParsed = '''
		model test {
			picturesPath : "a/b/c"
			package P {
				component C {
					in stream in1,
					out out1,
					in pinName {}
					runs {
						var testLiteral = 3;
						const testSum = 3 + 3;
						const testMultiplication = 6 * 7;
						in1 -> out1 takes Exp(1.0);
					}
				},
				softwareComponent S {
					in softwIn,
					out softwOut
				},
				mlComponent ML {
					in mlIn,
					out mlOut
				},
				physicalComponent PC {
					in pcIn,
					out pcOut
				},
				function F {
					in fIn,
					out fOut
				},
				actuator A {
					in AIn
				},
				heuristic H {
					firingStrategy OR
					in Hin,
					in Hin2,
					out Hout
				}				
				//sensor S {
				//	out Sout
				//	timeFunction EXP(1.0)
				//}
			}
		}
	''';

	@Test
	def void serializer() {
		e4smPackage.eINSTANCE.eClass() // Initialize the model
		//E4smStandaloneSetup.doSetup
		val reg = Resource.Factory.Registry.INSTANCE
		val m = reg.getExtensionToFactoryMap();
		m.put("e4sm", new XMIResourceFactoryImpl());

		// Obtain a new resource set
		val resSet = new ResourceSetImpl();

		// Get the resource
		println("Getting the resource Scenarios.e4sm...")
		val resource = resSet.getResource(URI.createURI("Scenarios.e4sm"), true)
		println("Resource loaded")
		// val f = e4smFactory.eINSTANCE
//    val myModel =  f.createModel => [
//      name = "Test"
//    ]
		val myModel = resource.contents.get(0) as Model
		println("Model '" + myModel.name + "' loaded, serializing it...")

		println(serializer.serialize(myModel))

	}

	@Test
	def void parseFiringStrategy() {
		val result = parseHelper.parse(toBeParsed)
		Assertions.assertEquals(result.packages.get(0).components.get(6).name, "H")
		Assertions.assertEquals(result.packages.get(0).components.get(6).firingStrategy, ComponentFiringStrategy::OR)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}

	@Test
	def void loadModel() {
		val result = parseHelper.parse(toBeParsed)
		Assertions.assertNotNull(result)
		Assertions.assertEquals(result.name, "test")
		Assertions.assertEquals(result.personsPicturesPath, "a/b/c")
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}

	@Test
	def void parsePackage() {
		val result = parseHelper.parse(toBeParsed)
		Assertions.assertEquals(result.packages.get(0).name, "P")
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}

	@Test
	def void parseComponent() {
		val result = parseHelper.parse(toBeParsed)
		Assertions.assertEquals(result.packages.get(0).components.get(0).name, "C")
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}

	@Test
	def void parseComponentPins() {
		val result = parseHelper.parse(toBeParsed)
		val component = result.packages.get(0).components.get(0)
		Assertions.assertTrue(component.pins.get(0).stream)
		Assertions.assertFalse(component.pins.get(1).stream)
		Assertions.assertEquals(component.pins.get(0).name, "in1")
		Assertions.assertEquals(component.pins.get(1).name, "out1")
		Assertions.assertEquals(component.pins.get(2).name, "pinName")

		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}

	// var testLiteral = 3;
	// const testSum = 3 + 3;
	// const testMultiplication = 6 * 7;
	@Test
	def void parseComponentExecution() {
		val result = parseHelper.parse(toBeParsed)
		val el = result.packages.get(0).components.get(0).execution.elements
		// TODO
//		Assertions.assertTrue((el.get(0) as Variable).expression.)
//		Assertions.assertFalse(component.pins.get(1).stream)
//		Assertions.assertEquals(component.pins.get(0).name, "in1")
//		Assertions.assertEquals(component.pins.get(1).name, "out1")
//		Assertions.assertEquals(component.pins.get(2).name, "pinName")
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}
}
