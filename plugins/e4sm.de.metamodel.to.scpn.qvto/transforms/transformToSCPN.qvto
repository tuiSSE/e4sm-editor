import SCPNConstructors;
import SCPNHelpers;
import transformPins;
import transformTypes;

modeltype e4sm "strict" uses e4sm("http://de.tu-ilmenau/e4sm/1.0.0");
modeltype execution "strict" uses execution("http://de.tu-ilmenau/e4sm/execution/1.0.0");
modeltype core "strict" uses core("http://de.tu-ilmenau/e4sm/core/1.0.0");
modeltype scpn "strict" uses scpn("http://timenet.tu-ilmenau.de/schema/SCPN");


transformation transformToSCPN(in e:e4sm, out s:scpn);
configuration property packageName : String;

main() {
	log("\nTransforming E4SM Model to Stochastic Colored Petri Net");
	
	var packages := e.rootObjects()[Model].packages;
	var selectedPackage : Package;
	
	assert fatal (not packages->isEmpty()) 
		with log("The provided model does not contain any package. There is nothing to transform.");
	
	if(packages->size() = 1){
		selectedPackage := packages->asOrderedSet()->first();
	}else{
		// if there is more than 1 package in the provided model, a packageName must be provided
		if(packages->size() > 1){
			assert fatal (packageName <> null and not packageName->isEmpty() and packageName <> "") 
			with log("Please set a package name (\'packageName\') to transform in the run configuration or have a single root package");
		};
		
		selectedPackage := packages->select(p:Package | p.name = packageName)->asOrderedSet()->first();
		
		assert fatal (not selectedPackage.oclIsUndefined()) 
		with log("Could not find any package named \"" + packageName + "\". Please check your Run Configurations.");
	};
	selectedPackage.map packageToSCPN();
	
	
	log("\nMain: Transformation completed to the end!");
}
	

/** Mappings **/
mapping Package::packageToSCPN() : SCPNNet{
	log("\nTransforming package " +  self.name);
	// Transform types
	//recordTokentype := e.rootObjects()[Model].types->map convert();
	recordTokentype := object RecordTokentype{
	id := "data_id";
	name := "Data";
	type := Type::text;
	
	// Specify the attributes
	attribute += object AttributeType{
			name := "n"; //name
			dataType:="string";
		};
	attribute += object AttributeType{
			name := "s"; //size
			dataType:="int";
		};
	attribute += object AttributeType{
			name := "l"; //length - if multiple elements are available
			dataType:="int";
		};
	attribute += object AttributeType{
			name := "gT"; //generationTime
			dataType:="DateTime";
		};
	attribute += object AttributeType{
			name := "d"; //isDefault
			dataType:="bool";
		};
		
	// TODO: only generate classification stuff if the model has one classification component
	attribute += object AttributeType{
			name := "ood"; //out of distribution
			dataType:="bool";
		};
		
	attribute += object AttributeType{
			name := "tL"; //trueLabel
			dataType:="int";
		};
		
	attribute += object AttributeType{
			name := "gL"; //guessedLabel
			dataType:="int";
		};
		
	graphics := object GraphicsType {
		x := 130;
	 	y := 1600
    };
	};
	
	comment += object CommentType{
		type:= Type::text;
		id := "data_comment_id";
		// TODO: only generate classification stuff if the model has one classification component
		commentText:="n: name (string)<br>s:size (int)<br>l:length (int)<br>gT:generationTime (DateTime)<br>d:isDefault (bool)<br>tL:trueLabel (int)<br>gL:guessedLabel (int);ood:Out of distribution (bool)";
		graphics := object GraphicsType {
			x := 110;
	 		y := 1650
    	};
	};
	
	// Attributes
	id := safeString(self.name);
	
	// Default SCPN Configuration for TimeNET:
	gridActive := true;
	netclass := "SCPN";
	sharpEdges := false;
	
	// Children
	if(self.components->isEmpty()){
		log("\n=== Warning: no components to transform ===");
	}
	else {
		log("\n=== Transforming all Components ===");
		var res = self.components->map transformComponent();
		place += res.pl;
		immediateTransition += res.iTr[ImmediateTransitionType];
		timedTransition += res.iTr[TimedTransitionType];
		arc += res.arcs;
		timedTransition += res.tt;
		substitutionTransition += res.st;
		measure += res.meas;
	};
	
	// Datastores
	if(self.datastores->isEmpty()){
		log("\n=== Info: No data stores to transform ===");
	}else{
		log("\n=== Transforming all Data Stores ===");
		var ds := self.datastores->map transformDataStore();
		place += ds.pl;
		immediateTransition += ds.iTr;
		arc += ds.arcs;
	};
	
	// Sectors
	if(self.sectors->isEmpty()){
		log("\n=== Info: No sectors to transform ===");
	}
	else {
		log("\n=== Transforming all Sectors ===");
		var sec := self.sectors->map transformSector();
		substitutionTransition += sec.st;
		place += sec.pl;
		immediateTransition += sec.iTr[ImmediateTransitionType];
		timedTransition += sec.iTr[TimedTransitionType];
		arc += sec.arcs;
		timedTransition += sec.tt;
		measure += sec.meas;
	};
	
	// Connectors
	if(self.connectors->isEmpty()){
		log("\n=== Warning: no connectors to transform ===");
	}
	else{
		log("\n=== Transforming all Connectors ===");
		var connectors := self.connectors->map connectorToSCPN();
		arc += connectors.arcs;
		timedTransition += connectors.tt;
	};
}

mapping Package::transformSpecificationPackage() : st: List(SubstitutionTransitionType), pl: List(PlaceType),
	iTr : List(TransitionType), arcs : List (ArcType), tt : List(TimedTransitionType),
	meas : List(MeasureType)	
	{
	log("\nTransforming specification package " +  self.name);
	//Children
	if(self.components->isEmpty()){
		log("\n=== Warning: no components to transform ===");
	}
	else {
		log("\n=== Transforming all Components ===");
		var res = self.components->map transformComponent();
		pl += res.pl;
		iTr += res.iTr[ImmediateTransitionType];
		tt += res.iTr[TimedTransitionType];
		arcs += res.arcs;
		tt += res.tt;
		st += res.st;
		meas += res.meas;
	};
	
	if(self.sectors->isEmpty()){
		log("\n=== Info: No sectors to transform ===");
	}
	else {
		log("\n=== Transforming all Sectors ===");
		var sec := self.sectors->map transformSector();
		st += sec.st;
		pl += sec.pl;
		iTr += sec.iTr[ImmediateTransitionType];
		tt += sec.iTr[TimedTransitionType];
		arcs += sec.arcs;
		tt += sec.tt;
	};
	
	//Transform connectors
	if(self.connectors->isEmpty()){
		log("\n=== Warning: no connectors to transform ===");
	}
	else{
		log("\n=== Transforming all Connectors ===");
		var connectors := self.connectors->map connectorToSCPN();
		arcs += connectors.arcs;
		tt += connectors.tt;
	};
}

mapping Connector::connectorToSCPN(): arcs:List(ArcType), tt:TimedTransitionType {
	init{
	    var name := self.computeName();
		log("\nTransforming connector " +  name);
		
	    assert fatal (name <> "Invalid connector") 
	    with log ("Invalid connector found. Please fix it or remove it from the model: " + self.toString());
	    
		tt := new TimedTransitionType(self.computeName());
	}

	var arc1 := new ArcType(self.computeName() + "_1");
	var arc2 := new ArcType(self.computeName() + "_2");
	
	//log("... place for arc source pin: " + self.source.toString());
	var sourcePlace : PlaceType := self.source.resolvePinPlace(self);
	arc1.fromNode := sourcePlace.id;
	arc1.toNode := tt.id;
	

	//log("... place for arc target pin: " + self.target.toString());
	var targetPlace : PlaceType := null;
	targetPlace := self.target.resolvePinPlace(self);
	
	arc2.fromNode := tt.id;
	arc2.toNode := targetPlace.id;
	
	arcs->add(arc1);
	arcs->add(arc2);

	log("Transformed connector " +  name);
}

/**
  Converts an E4SM Queue to a Petri net place queue
*/
helper e4sm::QueueType::convertQueueType() : scpn::QueueType {
	switch {
	case  (self = e4sm::QueueType::RANDOM){
			return scpn::QueueType::Random;
		}
		case  (self = e4sm::QueueType::FIFO){
			return scpn::QueueType::FIFO;
		}
		case  (self = e4sm::QueueType::LIFO){
			return scpn::QueueType::LIFO;
		}
		else{
			log("Unsupported queue type " + self.toString());
			return scpn::QueueType::Random;
		}
	};
	//Not needed, but it removes the warning
	return scpn::QueueType::Random;
}

mapping Sector::transformSector() : st: List(SubstitutionTransitionType), pl: List(PlaceType), iTr : List(TransitionType), arcs : List (ArcType), tt : List(TimedTransitionType), meas : List(MeasureType){
	var idName := safeString(self.name);
	log("\nTransforming sector " +  self.name);
	/*  TODO: nice to have, transform a sector inside a substitution transition
	var sTr : SubstitutionTransitionType = object SubstitutionTransitionType {};
	sTr.id := idName; //In TimeNET: 0.0, 0.1...
	
	//TimeNET's default:
	sTr.replication := 0;
    sTr.type:=scpn::Type::node;
	
	//If these are added, TimeNet says the network's schema is outdated.
	//serverType:=ServerTypeType::ExclusiveServer;
    //specType:=SpecTypeType::Automatic;
	//takeFirst:=false;
    //watch:=false;


 	sTr.graphics := object GraphicsType {
 		   orientation:=0;
 			x := 650;
	 		y := 200;
	 	};
 	sTr.label := object LabelType{
	 	   id:=idName+"_label";
	 	   text := idName;
	 	   type:=scpn::Type::text;
	 	   graphics := object GraphicsType {
			x := -10;
	 		y := -40;
	 	   };
	 	};
    sTr.net += object ReplicationType{
    	gridActive := true;
    	netclass:="SCPN";
    	sharpEdges := false;
    	id:=idName+"_subnet";
    };
    st += sTr;
    */
    
    if(self.sectors->size()>0){
    	log("Transforming subsectors...");
    	var res := self.sectors->map transformSector();
	    pl += res.pl;
	    iTr += res.iTr;
	    arcs += res.arcs;
	    tt += res.tt; 
	    st += res.st;
	    meas += res.meas;   
    }endif;
    
	// Datastores
	if(self.datastores->size()>0){
		log("Transforming all Data Stores...");
		var ds := self.datastores->map transformDataStore();
		pl += ds.pl;
		iTr += ds.iTr;
		arcs += ds.arcs;
	};
    
    var res = self.components-> map transformComponent();    
    pl += res.pl;
    iTr += res.iTr;
    arcs += res.arcs;
    tt += res.tt; 
    st += res.st;
    meas += res.meas;
    

    log("\tTransformed sector " +  self.name);
}

mapping Component::transformComponent() : pl: List(PlaceType), iTr : List(TransitionType), arcs : List (ArcType),
tt : List(TimedTransitionType), st : List (SubstitutionTransitionType), meas : List(MeasureType) {		
	init{
		log("\nTransforming component " +  self.name);
		
		var inputPins : OrderedSet(InputPin) := self.pins[e4sm::InputPin];
		var outputPins : OrderedSet(e4sm::OutputPin) := self.pins[e4sm::OutputPin];
		//pl := List{};
		//iTr := List{};
	
		//Transform all subcomponents contained by this component
		if(not self.components->isEmpty()) {
			log("Transforming all subcomponents");
			var res := self.components->map transformComponent();
			pl += res.pl;
			iTr += res.iTr;
			arcs += res.arcs;
			tt += res.tt;
			st += res.st;
			meas += res.meas;
		};
		
		// Datastores
		if(self.datastores->size()>0){
			log("Transforming all Data Stores...");
			var ds := self.datastores->map transformDataStore();
			pl += ds.pl;
			iTr += ds.iTr;
			arcs += ds.arcs;
		};
		
		var singleComponentReadyTransition : TransitionType := null;
		var multipleComponentReadyTransitions : OrderedSet(TransitionType);
		var timedTran : TimedTransitionType := null;
		
		//Generate the full component only if it is not redefined
		// - The component must not have subcomponents
		// - The component must not be specified by a package
		// - The component must not have an internal specification "runs { ... }"
		var isSimpleComponent : Boolean := false;
		if(self.components->isEmpty() and self.specifiedInPackage = null and self.execution = null) {
			isSimpleComponent := true;
			
			// Create measures for Sensors and Actuators, for simple components only
			if(self.oclIsKindOf(Sensor)) {
			    // Transitions have watch:true, the mainPlace is not generated anymore for sensors.
				// meas += self.oclAsType(Sensor).map sensorToMeasure();
			} else if(self.oclIsKindOf(Actuator)){
				meas += self.oclAsType(Actuator)->map actuatorToMeasure();
			};
			
			var componentMainPlace : PlaceType := null;
			

			if(self.isSensor()) {
			    log("Component is a sensor or has no inputs.");
				singleComponentReadyTransition := new TimedTransitionType(self.name + "_ready");
				singleComponentReadyTransition.oclAsType(TimedTransitionType).timeFunction := timeExpressionToString(self.timeFunction);
				singleComponentReadyTransition.watch := true;
				iTr->add(singleComponentReadyTransition);
			}else if(self.firingStrategy = ComponentFiringStrategy::AND){
					componentMainPlace := new PlaceType(self.name + "_main");
					pl->add(componentMainPlace);
					
					singleComponentReadyTransition := new ImmediateTransitionType(self.name + "_ready");
					iTr->add(singleComponentReadyTransition);

				    // The component only has one ready immediate transition which is connected to all input pins
					var readyToMain := new ArcType(self.name+"_ready_to_main");
					readyToMain.fromNode := singleComponentReadyTransition.id;
					readyToMain.toNode := componentMainPlace.id;
					
					// if the component is a Sensor, 
					// or if it has multiple input pins
					// or if at least an input pin has a "collect" value > 1 set
					if(self.oclIsTypeOf(e4sm::Sensor) or self.hasNoInputs() or inputPins->size() > 1 or inputPins->select(ip | ip.collect>1)->size()>0) {
						readyToMain.inscription.text := "new({})";
					};
					arcs->add(readyToMain);
				}
				else if (self.firingStrategy = ComponentFiringStrategy::OR) {
					// Every input pin gets an immediate "ready" transition
					componentMainPlace := new PlaceType(self.name + "_main");
					pl->add(componentMainPlace);
					
					var i:Integer := 1;
					self.pins[InputPin]->forEach(ip) {
						// Create the immediate transition
						var componentReadyTransition := new ImmediateTransitionType(self.name + "_ready_" + i.toString());
						iTr->add(componentReadyTransition);
						multipleComponentReadyTransitions->including(componentReadyTransition);
						
						// Create the Arc
						var readyToMain := new ArcType(self.name+"_ready" + i.toString() + "_to_main");
						readyToMain.fromNode := componentReadyTransition.id;
						readyToMain.toNode := componentMainPlace.id;
						
						// If this pin has a collect value set (>1)
						if(ip.collect > 1) {
							readyToMain.inscription.text := "new({})";
						};
						arcs->add(readyToMain);
						
						i := i + 1;
					}
				} else {
					assert fatal (false)
					with log("Unsupported firing strategy for component " + self.toString());
				};
			
			if(not self.isSensor()) {
			// Timed transition for the component execution
			timedTran := new TimedTransitionType(self.name + "_execution");
			timedTran.timeFunction := timeExpressionToString(self.timeFunction);
			tt->add(timedTran);
			
			// Arc between the main Place and the timed transition
			var mainToTimed := new ArcType(self.name + "_main_to_timed");
			mainToTimed.fromNode := componentMainPlace.id;
			mainToTimed.toNode := timedTran.id;
			arcs->add(mainToTimed);
			}
		};
		
		
		// Check if the component can be executed in parallel
		if(self.oclIsKindOf(SoftwareComponent) and self.firingStrategy = ComponentFiringStrategy::AND){
		var servers : Integer = self.oclAsType(SoftwareComponent).numberOfServers;
		if(servers = -1){
			timedTran.serverType := ServerTypeType::InfiniteServer;
			timedTran.watch := true;
		}
		else if(servers > 1) {
			// The value is <> 1, add the semaphore place with 2 arcs
			// and change the execution transition server type
			
			timedTran.serverType := ServerTypeType::InfiniteServer;
			
			// Create the place
			var sem : PlaceType := new PlaceType(self.name + "_sem");
			
			// Add the tokens
			var i : Integer := 0;
			while (i < servers) {
			    sem.initialMarking := sem.initialMarking + "0";
				i := i + 1;
				// Add a comma if it's not the last one
				if(i < servers){
					sem.initialMarking := sem.initialMarking + ", ";
				}
			};
			
			pl->add(sem);
			
			// Create the Arcs
			var semBack := new ArcType(self.name+"_semBack");
			semBack.inscription.text := "new({})";
			semBack.fromNode := timedTran.id;
			semBack.toNode := sem.id;
			arcs->add(semBack);
			
			var semReady := new ArcType(self.name+"_semReady");
			semReady.inscription.text := "limit";
			semReady.fromNode := sem.id;
			semReady.toNode := singleComponentReadyTransition.id;
			arcs->add(semReady);
			
			var semMeasure := new MeasureType(self.name + "_in_use");
			semMeasure.expression := servers.toString() + " - #" + safeString(self.name) + "_sem";
			meas->add(semMeasure);
		}
		
		};
		
		
		// Transform the input pins
		var i:Integer := 1;
		inputPins->forEach(ip) {
			if (ip.requiresSimpleTransformation()) {
				//OUT FCFS
				//Create the place
			    var inputPinPlace := ip.map simpleTransformOutputPin(self.name, i);
			    pl += inputPinPlace;
				
				//Create an arc to connect the place to the simple component 
					
				if(isSimpleComponent) {
					var arcToTransition = new ArcType(inputPinPlace.id + "_to_" + self.name);
					arcToTransition.fromNode := inputPinPlace.id;
					
					if(self.firingStrategy = ComponentFiringStrategy::AND) {
						arcToTransition.toNode := singleComponentReadyTransition.id;
						if(inputPins->size() > 1) {
							// use different token names
							log("Changing variable inscription to " + i.toString());
							arcToTransition.inscription.text := mergeArcNames->at(i);
						}
					} else if(self.firingStrategy = ComponentFiringStrategy::OR){
						// every arc leads to a different transition, different token names are not needed
						arcToTransition.toNode := safeString(self.name) + "_ready_" + i.toString() + immediateTransSuffix;
					} else{
						assert fatal (false)
						with log("Unsupported firing strategy for component " + self.toString());
					};
					
					// Add multiplicity, if needed
					if(ip.collect > 1) {
						// Add a multiplicity in the arc.
						 arcToTransition.inscription.text := ip.collect.toString()  + "'" + arcToTransition.inscription.text
						 
 						// An alternative method would be to add a global guard: #placeName >= collectValue, but in that case then all collected
 						// tokens are transferred when the global guard is satisfied
						// singleComponentReadyTransition.globalGuard := "#"+inputPinPlace.label.text + ">=" + ip.collect.toString();
					}endif;
					
					arcs->add(arcToTransition);
				}; //else this component is redefined and not generated completely
			} else if (ip.requiresMerge()) {
				// Merge
				var transformationResult := ip.map transformPinMerge(self.name, i);
			    pl += transformationResult.pl;
			    iTr += transformationResult.it;
			    arcs += transformationResult.arcs;
			    if(isSimpleComponent) {
			    	var arcToTransition = new ArcType(transformationResult.pl->first().id + "_to_" + self.name);
					arcToTransition.fromNode := transformationResult.pl->first().id;
					arcToTransition.toNode := singleComponentReadyTransition.id;
					arcs->add(arcToTransition);			    
			    }endif;

			} else if(ip.requiresDuplicate())
			{
				var transformationResult := ip.map transformPinDuplicate(self.name, i);
			    pl += transformationResult.pl;
			    iTr += transformationResult.it;
			    arcs += transformationResult.arcs;
			} else if(ip.requiresMergeAndDuplicate())
			{
				var transformationResult := ip.map transformPinMergeAndDuplicate(self.name, i);
			    pl += transformationResult.pl;
			    iTr += transformationResult.it;
			    arcs += transformationResult.arcs;
			}endif;
			
			//If the pin is optional, also add the extra transitions
			if (ip.optional) {
			
			};
			
			i := i + 1;
		};
		
		// Transform all output pins
		i := 1;
		outputPins->forEach(op) {
			if (op.requiresSimpleTransformation()) {
				//OUT FCFS
				//Create the place
			    var outputPinPlace := op.map simpleTransformOutputPin(self.name, i);
			    pl += outputPinPlace;
				
				//Create an arc to connect the the component to the place
				if(isSimpleComponent) {
					var arcFromTransition = new ArcType(outputPinPlace.id + "_from_" + self.name);
					if(self.isSensor()){
						arcFromTransition.fromNode := singleComponentReadyTransition.id;
					}else{
						arcFromTransition.fromNode := timedTran.id;
					};
					arcFromTransition.toNode := outputPinPlace.id;
					
					// TODO: maybe the following line only applies to sensors
					arcFromTransition.inscription.text := "new({})"; //TODO: improve specification
					
					// Add multiplicity, if needed
					if(op.amplify > 1) {
						arcFromTransition.inscription.text := op.amplify.toString()  + "'" + arcFromTransition.inscription.text
					}endif;
					
					arcs->add(arcFromTransition);
				}; // else this component is redefined and not generated completely
			} else if (op.requiresMerge()) {
				//OUT Merge
				var outputPin := op.map transformPinMerge(self.name, i);
			    pl += outputPin.pl;
			    iTr += outputPin.it;
			    arcs += outputPin.arcs;
			} else if(op.requiresDuplicate())	{
				var outputPin := op.map transformPinDuplicate(self.name, i);
			    pl += outputPin.pl;
			    iTr += outputPin.it;
			    arcs += outputPin.arcs;
			    
			    if(isSimpleComponent) {
			    var arcFromTransition = new ArcType(outputPin.pl->first().id + "_from_" + self.name);
					if(self.isSensor()){
						arcFromTransition.fromNode := singleComponentReadyTransition.id;
					}else{
						arcFromTransition.fromNode := timedTran.id;
					};
					arcFromTransition.toNode := outputPin.pl->first().id;
					arcFromTransition.inscription.text :=  "new({})"; //TODO: improve specification
					
					// Add multiplicity, if needed
					if(op.oclIsTypeOf(OutputPin) and op.amplify > 1) {
						arcFromTransition.inscription.text := op.amplify.toString()  + "'" + arcFromTransition.inscription.text
					}endif;
					
					arcs->add(arcFromTransition);
			    };
			} else if(op.requiresMergeAndDuplicate())
			{
				var outputPin := op.map transformPinMergeAndDuplicate(self.name, i);
			    pl += outputPin.pl;
			    iTr += outputPin.it;
			    arcs += outputPin.arcs;
			} endif;
			i := i + 1;
		};
		
		// Transform the execution, if any was defined
		if (self.execution != null) {
			self.execution.elements->forEach(el){
				if(el.oclIsTypeOf(Flow)) {
				   var f : Flow = el.oclAsType(Flow);
				   
				   // Create the timed transition
				   var flowTT : TimedTransitionType := new TimedTransitionType(f.source.oclAsType(NamedElement).name+ "_to_" + f.target.oclAsType(NamedElement).name+"_flow");				   
				   flowTT.timeFunction := timeExpressionToString(f.timeFunction);
				   tt += flowTT;
				   
				   // Create an arc to connect the source element to the transition
				   var sourceArc : ArcType := new ArcType(f.source.oclAsType(NamedElement).name + "_flow_source");
				   sourceArc.fromNode := safeString(self.name + f.source.oclAsType(Pin).getDirectionShort() + inputPins->indexOf(f.source).toString() + placeSuffix);
				   sourceArc.toNode := flowTT.id;
				   arcs += sourceArc;
				   
				   // Create an arc to connect the target element to the transition
				   var targetArc : ArcType := new ArcType(f.target.oclAsType(NamedElement).name + "_flow_target");
				   targetArc.fromNode := flowTT.id;
				   targetArc.toNode := safeString(self.name + f.target.oclAsType(Pin).getDirectionShort() + outputPins->indexOf(f.target).toString() + placeSuffix);			   
				   
				   arcs += targetArc;
				}else{
				   log ("Unsupported execution element type");
				};
			};
		};
		
		//Generate the specifying package, if any.
		if(not (self.specifiedInPackage = null)){
			var res := self.specifiedInPackage.map transformSpecificationPackage();
			pl += res.pl;
			iTr += res.iTr;
			tt += res.tt;
			arcs += res.arcs;
			st += res.st;
			meas += res.meas;
		}endif;
	 }
	 log("Transformed component '" +  self.name + "' to " + pl->size().toString()+ " place(s), "
	  + iTr[ImmediateTransitionType]->size().toString() + " immediate transition(s) and " 
	  + iTr[TimedTransitionType]->size().toString() + " timed transition(s) and "
	  + meas->size().toString() + " measure");
}

mapping DataStore::transformDataStore() : arcs : List(ArcType), iTr : List(ImmediateTransitionType), pl : List(PlaceType){
	init {
		assert fatal (self.name->size()>0) with log ("Datastore must have a name");
		// Create the 3 Places
		var inputPlace : PlaceType := new PlaceType(self.name + "_ds_in");
		inputPlace.queue:= scpn::QueueType::FIFO;
		pl += inputPlace;
		
		var outputPlace : PlaceType := new PlaceType(self.name + "_ds_out");
		pl += outputPlace;
		
		var mainPlace : PlaceType := new PlaceType(self.name + "_ds_main");
		mainPlace.capacity := "1";
		pl += mainPlace;
		
		// Create the 3 immediate transitions
		var initTransition : ImmediateTransitionType := new ImmediateTransitionType(self.name + "_ds_init");
		initTransition.globalGuard := "#" + mainPlace.label.text+"==0";
		iTr += initTransition;
		
		var updateTransition : ImmediateTransitionType := new ImmediateTransitionType(self.name + "_ds_update");
		updateTransition.priority := 2;
		iTr += updateTransition;
		
		var readTransition : ImmediateTransitionType := new ImmediateTransitionType(self.name + "_ds_read");
		readTransition.globalGuard := "#" + outputPlace.label.text+"==0";
		iTr += readTransition;
		
		// Create the 9 arcs
		// 4 arcs of the Main "rhombus":
		var inToInit : ArcType := new ArcType(self.name + "_inToInit");
		inToInit.fromNode := inputPlace.id;
		inToInit.toNode := initTransition.id;
		arcs += inToInit;
		
		var initToMain : ArcType := new ArcType(self.name + "_initToMain");
		initToMain.fromNode := initTransition.id;
		initToMain.toNode := mainPlace.id;
		arcs += initToMain;
		
		var inToUpdate : ArcType := new ArcType(self.name + "_inToUpdate");
		inToUpdate.fromNode := inputPlace.id;
		inToUpdate.toNode := updateTransition.id;
		arcs += inToUpdate;
		
		var updateToMain : ArcType := new ArcType(self.name + "_updateToMain");
		updateToMain.fromNode := updateTransition.id;
		updateToMain.toNode := mainPlace.id;
		arcs += updateToMain;
		
		// 3 Read arcs
		var mainToRead : ArcType := new ArcType(self.name + "_mainToRead");
		mainToRead.fromNode := mainPlace.id;
		mainToRead.toNode := readTransition.id;
		arcs += mainToRead;
		
		var readToMain : ArcType := new ArcType(self.name + "_readToMain");
		readToMain.fromNode :=readTransition.id;
		readToMain.toNode := mainPlace.id;
		arcs += readToMain;
		
		var readToOut : ArcType := new ArcType(self.name + "_readToOut");
		readToOut.fromNode := readTransition.id;
		readToOut.toNode := outputPlace.id;
		readToOut.inscription.text := "copy " + readToOut.inscription.text;
		arcs += readToOut;
		
		// 2 arc to remove the tokens
		var removeFromMain : ArcType := new ArcType(self.name + "_removeFromMain");
		removeFromMain.fromNode := mainPlace.id;
		removeFromMain.toNode := updateTransition.id;
		removeFromMain.inscription.text := "delete";
		arcs += removeFromMain;
		
		var removeFromOut : ArcType := new ArcType(self.name + "_removeFromOut");
		removeFromOut.fromNode := outputPlace.id;
		removeFromOut.toNode := updateTransition.id;
		removeFromOut.inscription.text := "remove";
		arcs += removeFromOut;
	}
	 log("Transformed datastore '" +  self.name + "' to " + pl->size().toString()+ " place(s), "
	  + iTr->size().toString() + " immediate transition(s) and " 
	  + arcs->size().toString() + " arc(s)");
}


mapping Sensor::sensorToMeasure() : scpn::MeasureType {
	result.id := safeString(self.name+"_s_meas");
	result.eval := MeasureEvalType::Cumulative;
	result.expression := "#" + safeString(self.name) + "_main";
	result.name := safeString(self.name) + "Ready";
	result.type := Type::text;
	result.watch := true;
	result._result := "";
	result.graphics := object GraphicsType{x:=0; y:=0};
	log("Transformed sensor '" +  self.name + "' to measure");
}

mapping Actuator::actuatorToMeasure() : scpn::MeasureType {
	result.id := safeString(self.name+"_a_meas");
	result.eval := MeasureEvalType::Cumulative;
	result.expression := "#" + safeString(self.name) + "_main";
	result.name := safeString(self.name) + "Ready";
	result.type := Type::text;
	result.watch := true;
	result._result := "";
	result.graphics := object GraphicsType{x:=0; y:=0};
	log("Transformed actuator '" +  self.name + "' to measure");
}