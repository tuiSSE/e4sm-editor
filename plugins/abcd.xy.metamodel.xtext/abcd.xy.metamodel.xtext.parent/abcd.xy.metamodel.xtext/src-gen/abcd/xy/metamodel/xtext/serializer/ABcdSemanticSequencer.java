/*
 * generated by Xtext 2.27.0
 */
package abcd.xy.metamodel.xtext.serializer;

import com.google.inject.Inject;
import abcd.xy.metamodel.abcd.Actor;
import abcd.xy.metamodel.abcd.Actuator;
import abcd.xy.metamodel.abcd.Component;
import abcd.xy.metamodel.abcd.Connector;
import abcd.xy.metamodel.abcd.DataStore;
import abcd.xy.metamodel.abcd.ExternalDependency;
import abcd.xy.metamodel.abcd.Function;
import abcd.xy.metamodel.abcd.Heuristic;
import abcd.xy.metamodel.abcd.Human;
import abcd.xy.metamodel.abcd.Import;
import abcd.xy.metamodel.abcd.InputPin;
import abcd.xy.metamodel.abcd.LogicalConnector;
import abcd.xy.metamodel.abcd.MachineLearningComponent;
import abcd.xy.metamodel.abcd.Model;
import abcd.xy.metamodel.abcd.OutputPin;
import abcd.xy.metamodel.abcd.Person;
import abcd.xy.metamodel.abcd.PhysicalComponent;
import abcd.xy.metamodel.abcd.PhysicalConnector;
import abcd.xy.metamodel.abcd.Robot;
import abcd.xy.metamodel.abcd.Sector;
import abcd.xy.metamodel.abcd.Sensor;
import abcd.xy.metamodel.abcd.SoftwareComponent;
import abcd.xy.metamodel.abcd.analysis.AnalysisPackage;
import abcd.xy.metamodel.abcd.analysis.ParameterDefinition;
import abcd.xy.metamodel.abcd.core.BooleanAttribute;
import abcd.xy.metamodel.abcd.core.ClassAttribute;
import abcd.xy.metamodel.abcd.core.CorePackage;
import abcd.xy.metamodel.abcd.core.DoubleAttribute;
import abcd.xy.metamodel.abcd.core.IntegerAttribute;
import abcd.xy.metamodel.abcd.core.LiteralBoolean;
import abcd.xy.metamodel.abcd.core.LiteralByte;
import abcd.xy.metamodel.abcd.core.LiteralCharacter;
import abcd.xy.metamodel.abcd.core.LiteralDate;
import abcd.xy.metamodel.abcd.core.LiteralDouble;
import abcd.xy.metamodel.abcd.core.LiteralFloat;
import abcd.xy.metamodel.abcd.core.LiteralInteger;
import abcd.xy.metamodel.abcd.core.LiteralLong;
import abcd.xy.metamodel.abcd.core.LiteralNull;
import abcd.xy.metamodel.abcd.core.LiteralShort;
import abcd.xy.metamodel.abcd.core.LiteralString;
import abcd.xy.metamodel.abcd.core.StringAttribute;
import abcd.xy.metamodel.abcd.core.TypeSpecification;
import abcd.xy.metamodel.abcd.core.Variant;
import abcd.xy.metamodel.abcd.abcdPackage;
import abcd.xy.metamodel.abcd.execution.Addition;
import abcd.xy.metamodel.abcd.execution.AssignableElementReference;
import abcd.xy.metamodel.abcd.execution.Assignment;
import abcd.xy.metamodel.abcd.execution.Const;
import abcd.xy.metamodel.abcd.execution.Execution;
import abcd.xy.metamodel.abcd.execution.ExecutionPackage;
import abcd.xy.metamodel.abcd.execution.Flow;
import abcd.xy.metamodel.abcd.execution.FlowFinal;
import abcd.xy.metamodel.abcd.execution.ForkNode;
import abcd.xy.metamodel.abcd.execution.MergeNode;
import abcd.xy.metamodel.abcd.execution.Multiplication;
import abcd.xy.metamodel.abcd.execution.TimeFunction;
import abcd.xy.metamodel.abcd.execution.Variable;
import abcd.xy.metamodel.abcd.execution.VariableRef;
import abcd.xy.metamodel.xtext.services.ABcdGrammarAccess;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.ecore.EAnnotation;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.EEnumLiteral;
import org.eclipse.emf.ecore.EGenericType;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EOperation;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EParameter;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.ETypeParameter;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ABcdSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ABcdGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AnalysisPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AnalysisPackage.PARAMETER:
				sequence_Parameter(context, (abcd.xy.metamodel.abcd.analysis.Parameter) semanticObject); 
				return; 
			case AnalysisPackage.PARAMETER_DEFINITION:
				sequence_ParameterDefinition(context, (ParameterDefinition) semanticObject); 
				return; 
			}
		else if (epackage == CorePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CorePackage.BOOLEAN_ATTRIBUTE:
				sequence_BooleanAttribute(context, (BooleanAttribute) semanticObject); 
				return; 
			case CorePackage.CLASS_ATTRIBUTE:
				sequence_ClassAttribute(context, (ClassAttribute) semanticObject); 
				return; 
			case CorePackage.DOUBLE_ATTRIBUTE:
				sequence_DoubleAttribute(context, (DoubleAttribute) semanticObject); 
				return; 
			case CorePackage.INTEGER_ATTRIBUTE:
				sequence_IntegerAttribute(context, (IntegerAttribute) semanticObject); 
				return; 
			case CorePackage.LITERAL_BOOLEAN:
				sequence_LiteralBoolean(context, (LiteralBoolean) semanticObject); 
				return; 
			case CorePackage.LITERAL_BYTE:
				sequence_LiteralByte(context, (LiteralByte) semanticObject); 
				return; 
			case CorePackage.LITERAL_CHARACTER:
				sequence_LiteralCharacter(context, (LiteralCharacter) semanticObject); 
				return; 
			case CorePackage.LITERAL_DATE:
				sequence_LiteralDate(context, (LiteralDate) semanticObject); 
				return; 
			case CorePackage.LITERAL_DOUBLE:
				sequence_LiteralDouble(context, (LiteralDouble) semanticObject); 
				return; 
			case CorePackage.LITERAL_FLOAT:
				sequence_LiteralFloat(context, (LiteralFloat) semanticObject); 
				return; 
			case CorePackage.LITERAL_INTEGER:
				sequence_LiteralInteger(context, (LiteralInteger) semanticObject); 
				return; 
			case CorePackage.LITERAL_LONG:
				sequence_LiteralLong(context, (LiteralLong) semanticObject); 
				return; 
			case CorePackage.LITERAL_NULL:
				sequence_LiteralNull(context, (LiteralNull) semanticObject); 
				return; 
			case CorePackage.LITERAL_SHORT:
				sequence_LiteralShort(context, (LiteralShort) semanticObject); 
				return; 
			case CorePackage.LITERAL_STRING:
				sequence_LiteralString(context, (LiteralString) semanticObject); 
				return; 
			case CorePackage.STRING_ATTRIBUTE:
				sequence_StringAttribute(context, (StringAttribute) semanticObject); 
				return; 
			case CorePackage.TYPE_SPECIFICATION:
				sequence_TypeSpecification(context, (TypeSpecification) semanticObject); 
				return; 
			case CorePackage.VARIANT:
				sequence_Variant(context, (Variant) semanticObject); 
				return; 
			}
		else if (epackage == abcdPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case abcdPackage.ACTOR:
				sequence_Actor_Impl(context, (Actor) semanticObject); 
				return; 
			case abcdPackage.ACTUATOR:
				sequence_Actuator(context, (Actuator) semanticObject); 
				return; 
			case abcdPackage.COMPONENT:
				sequence_Component_Impl(context, (Component) semanticObject); 
				return; 
			case abcdPackage.CONNECTOR:
				sequence_Connector_Impl(context, (Connector) semanticObject); 
				return; 
			case abcdPackage.DATA_STORE:
				sequence_DataStore(context, (DataStore) semanticObject); 
				return; 
			case abcdPackage.EXTERNAL_DEPENDENCY:
				sequence_ExternalDependency(context, (ExternalDependency) semanticObject); 
				return; 
			case abcdPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case abcdPackage.HEURISTIC:
				sequence_Heuristic(context, (Heuristic) semanticObject); 
				return; 
			case abcdPackage.HUMAN:
				sequence_Human_Impl(context, (Human) semanticObject); 
				return; 
			case abcdPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case abcdPackage.INPUT_PIN:
				sequence_InputPin(context, (InputPin) semanticObject); 
				return; 
			case abcdPackage.LOGICAL_CONNECTOR:
				sequence_LogicalConnector(context, (LogicalConnector) semanticObject); 
				return; 
			case abcdPackage.MACHINE_LEARNING_COMPONENT:
				sequence_MachineLearningComponent(context, (MachineLearningComponent) semanticObject); 
				return; 
			case abcdPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case abcdPackage.OUTPUT_PIN:
				sequence_OutputPin(context, (OutputPin) semanticObject); 
				return; 
			case abcdPackage.PACKAGE:
				sequence_Package(context, (abcd.xy.metamodel.abcd.Package) semanticObject); 
				return; 
			case abcdPackage.PERSON:
				sequence_Person(context, (Person) semanticObject); 
				return; 
			case abcdPackage.PHYSICAL_COMPONENT:
				sequence_PhysicalComponent_Impl(context, (PhysicalComponent) semanticObject); 
				return; 
			case abcdPackage.PHYSICAL_CONNECTOR:
				sequence_PhysicalConnector(context, (PhysicalConnector) semanticObject); 
				return; 
			case abcdPackage.ROBOT:
				sequence_Robot(context, (Robot) semanticObject); 
				return; 
			case abcdPackage.SECTOR:
				sequence_Sector(context, (Sector) semanticObject); 
				return; 
			case abcdPackage.SENSOR:
				sequence_Sensor(context, (Sensor) semanticObject); 
				return; 
			case abcdPackage.SOFTWARE_COMPONENT:
				sequence_SoftwareComponent_Impl(context, (SoftwareComponent) semanticObject); 
				return; 
			}
		else if (epackage == EcorePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EcorePackage.EANNOTATION:
				sequence_EAnnotation(context, (EAnnotation) semanticObject); 
				return; 
			case EcorePackage.EATTRIBUTE:
				sequence_EAttribute(context, (EAttribute) semanticObject); 
				return; 
			case EcorePackage.ECLASS:
				sequence_EClass(context, (EClass) semanticObject); 
				return; 
			case EcorePackage.EDATA_TYPE:
				sequence_EDataType_Impl(context, (EDataType) semanticObject); 
				return; 
			case EcorePackage.EENUM:
				sequence_EEnum(context, (EEnum) semanticObject); 
				return; 
			case EcorePackage.EENUM_LITERAL:
				sequence_EEnumLiteral(context, (EEnumLiteral) semanticObject); 
				return; 
			case EcorePackage.EGENERIC_TYPE:
				sequence_EGenericType(context, (EGenericType) semanticObject); 
				return; 
			case EcorePackage.EOBJECT:
				sequence_EObject(context, (EObject) semanticObject); 
				return; 
			case EcorePackage.EOPERATION:
				sequence_EOperation(context, (EOperation) semanticObject); 
				return; 
			case EcorePackage.EPARAMETER:
				sequence_EParameter(context, (EParameter) semanticObject); 
				return; 
			case EcorePackage.EREFERENCE:
				sequence_EReference(context, (EReference) semanticObject); 
				return; 
			case EcorePackage.ESTRING_TO_STRING_MAP_ENTRY:
				sequence_EStringToStringMapEntry(context, (Map.Entry) semanticObject); 
				return; 
			case EcorePackage.ETYPE_PARAMETER:
				sequence_ETypeParameter(context, (ETypeParameter) semanticObject); 
				return; 
			}
		else if (epackage == ExecutionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExecutionPackage.ADDITION:
				sequence_Addition(context, (Addition) semanticObject); 
				return; 
			case ExecutionPackage.ASSIGNABLE_ELEMENT_REFERENCE:
				sequence_AssignableElementReference(context, (AssignableElementReference) semanticObject); 
				return; 
			case ExecutionPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case ExecutionPackage.CONST:
				sequence_Const(context, (Const) semanticObject); 
				return; 
			case ExecutionPackage.EXECUTION:
				sequence_Execution(context, (Execution) semanticObject); 
				return; 
			case ExecutionPackage.FLOW:
				sequence_Flow(context, (Flow) semanticObject); 
				return; 
			case ExecutionPackage.FLOW_FINAL:
				sequence_FlowFinal(context, (FlowFinal) semanticObject); 
				return; 
			case ExecutionPackage.FORK_NODE:
				sequence_ForkNode(context, (ForkNode) semanticObject); 
				return; 
			case ExecutionPackage.MERGE_NODE:
				sequence_MergeNode(context, (MergeNode) semanticObject); 
				return; 
			case ExecutionPackage.MULTIPLICATION:
				sequence_Multiplication(context, (Multiplication) semanticObject); 
				return; 
			case ExecutionPackage.TIME_FUNCTION:
				sequence_ExeTimeFunction(context, (TimeFunction) semanticObject); 
				return; 
			case ExecutionPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case ExecutionPackage.VARIABLE_REF:
				sequence_VariableRef(context, (VariableRef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Actor returns Actor
	 *     Actor_Impl returns Actor
	 *
	 * Constraint:
	 *     (name=EString documentation=EString?)
	 * </pre>
	 */
	protected void sequence_Actor_Impl(ISerializationContext context, Actor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Actuator
	 *     Actuator returns Actuator
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution?
	 *     )
	 * </pre>
	 */
	protected void sequence_Actuator(ISerializationContext context, Actuator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Elements returns Addition
	 *     Expression returns Addition
	 *     Addition returns Addition
	 *     Addition.Addition_2_0 returns Addition
	 *     Primary returns Addition
	 *
	 * Constraint:
	 *     (left=Multiplication | (left=Addition_Addition_2_0 (addition?='+' | subtraction?='-') right=Multiplication))
	 * </pre>
	 */
	protected void sequence_Addition(ISerializationContext context, Addition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignableElementReference returns AssignableElementReference
	 *
	 * Constraint:
	 *     ref=[AssignableElement|ID]
	 * </pre>
	 */
	protected void sequence_AssignableElementReference(ISerializationContext context, AssignableElementReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExecutionPackage.Literals.ASSIGNABLE_ELEMENT_REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExecutionPackage.Literals.ASSIGNABLE_ELEMENT_REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignableElementReferenceAccess().getRefAssignableElementIDTerminalRuleCall_0_1(), semanticObject.eGet(ExecutionPackage.Literals.ASSIGNABLE_ELEMENT_REFERENCE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Elements returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (target=AssignableElementReference expression=Expression)
	 * </pre>
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExecutionPackage.Literals.ASSIGNMENT__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExecutionPackage.Literals.ASSIGNMENT__TARGET));
			if (transientValues.isValueTransient(semanticObject, ExecutionPackage.Literals.ASSIGNMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExecutionPackage.Literals.ASSIGNMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getTargetAssignableElementReferenceParserRuleCall_0_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getAssignmentAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeSpecification returns BooleanAttribute
	 *     BooleanAttribute returns BooleanAttribute
	 *
	 * Constraint:
	 *     (array?='['? name=ID defaultValue=EBoolean?)
	 * </pre>
	 */
	protected void sequence_BooleanAttribute(ISerializationContext context, BooleanAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeSpecification returns ClassAttribute
	 *     ClassAttribute returns ClassAttribute
	 *
	 * Constraint:
	 *     (type=[TypeSpecification|ID] array?='['? name=ID)
	 * </pre>
	 */
	protected void sequence_ClassAttribute(ISerializationContext context, ClassAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Component
	 *     Component_Impl returns Component
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution?
	 *     )
	 * </pre>
	 */
	protected void sequence_Component_Impl(ISerializationContext context, Component semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Connector returns Connector
	 *     Connector_Impl returns Connector
	 *
	 * Constraint:
	 *     (name=EString source=[Pin|EString] target=[Pin|EString] documentation=EString? (parameters+=Parameter parameters+=Parameter*)?)
	 * </pre>
	 */
	protected void sequence_Connector_Impl(ISerializationContext context, Connector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Elements returns Const
	 *     Const returns Const
	 *
	 * Constraint:
	 *     (name=ID expression=Expression?)
	 * </pre>
	 */
	protected void sequence_Const(ISerializationContext context, Const semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataStore returns DataStore
	 *     DataNode returns DataStore
	 *
	 * Constraint:
	 *     (type=[TypeSpecification|ID]? name=EString documentation=EString? (parameters+=Parameter parameters+=Parameter*)?)
	 * </pre>
	 */
	protected void sequence_DataStore(ISerializationContext context, DataStore semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeSpecification returns DoubleAttribute
	 *     DoubleAttribute returns DoubleAttribute
	 *
	 * Constraint:
	 *     (array?='['? name=ID defaultValue=EDouble?)
	 * </pre>
	 */
	protected void sequence_DoubleAttribute(ISerializationContext context, DoubleAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EAnnotation returns EAnnotation
	 *
	 * Constraint:
	 *     (
	 *         source=EString? 
	 *         (references+=[EObject|EString] references+=[EObject|EString]*)? 
	 *         (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)? 
	 *         (details+=EStringToStringMapEntry details+=EStringToStringMapEntry*)? 
	 *         (contents+=EObject contents+=EObject*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_EAnnotation(ISerializationContext context, EAnnotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EStructuralFeature returns EAttribute
	 *     EAttribute returns EAttribute
	 *
	 * Constraint:
	 *     (
	 *         volatile?='volatile'? 
	 *         transient?='transient'? 
	 *         unsettable?='unsettable'? 
	 *         derived?='derived'? 
	 *         iD?='iD'? 
	 *         name=EString 
	 *         ordered=EBoolean? 
	 *         unique=EBoolean? 
	 *         lowerBound=EInt? 
	 *         upperBound=EInt? 
	 *         changeable=EBoolean? 
	 *         defaultValueLiteral=EString? 
	 *         eType=[EClassifier|EString]? 
	 *         (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)? 
	 *         eGenericType=EGenericType?
	 *     )
	 * </pre>
	 */
	protected void sequence_EAttribute(ISerializationContext context, EAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EClassifier returns EClass
	 *     EClass returns EClass
	 *
	 * Constraint:
	 *     (
	 *         abstract?='abstract'? 
	 *         interface?='interface'? 
	 *         name=EString 
	 *         instanceClassName=EString? 
	 *         instanceTypeName=EString? 
	 *         (eSuperTypes+=[EClass|EString] eSuperTypes+=[EClass|EString]*)? 
	 *         (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)? 
	 *         (eTypeParameters+=ETypeParameter eTypeParameters+=ETypeParameter*)? 
	 *         (eOperations+=EOperation eOperations+=EOperation*)? 
	 *         (eStructuralFeatures+=EStructuralFeature eStructuralFeatures+=EStructuralFeature*)? 
	 *         (eGenericSuperTypes+=EGenericType eGenericSuperTypes+=EGenericType*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_EClass(ISerializationContext context, EClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EDataType returns EDataType
	 *     EClassifier returns EDataType
	 *     EDataType_Impl returns EDataType
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         instanceClassName=EString? 
	 *         instanceTypeName=EString? 
	 *         serializable=EBoolean? 
	 *         (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)? 
	 *         (eTypeParameters+=ETypeParameter eTypeParameters+=ETypeParameter*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_EDataType_Impl(ISerializationContext context, EDataType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EEnumLiteral returns EEnumLiteral
	 *
	 * Constraint:
	 *     (name=EString value=EInt? literal=EString? (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)?)
	 * </pre>
	 */
	protected void sequence_EEnumLiteral(ISerializationContext context, EEnumLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EDataType returns EEnum
	 *     EClassifier returns EEnum
	 *     EEnum returns EEnum
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         instanceClassName=EString? 
	 *         instanceTypeName=EString? 
	 *         serializable=EBoolean? 
	 *         (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)? 
	 *         (eTypeParameters+=ETypeParameter eTypeParameters+=ETypeParameter*)? 
	 *         (eLiterals+=EEnumLiteral eLiterals+=EEnumLiteral*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_EEnum(ISerializationContext context, EEnum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EGenericType returns EGenericType
	 *
	 * Constraint:
	 *     (
	 *         eTypeParameter=[ETypeParameter|EString]? 
	 *         eClassifier=[EClassifier|EString]? 
	 *         eUpperBound=EGenericType? 
	 *         (eTypeArguments+=EGenericType eTypeArguments+=EGenericType*)? 
	 *         eLowerBound=EGenericType?
	 *     )
	 * </pre>
	 */
	protected void sequence_EGenericType(ISerializationContext context, EGenericType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EObject returns EObject
	 *
	 * Constraint:
	 *     {EObject}
	 * </pre>
	 */
	protected void sequence_EObject(ISerializationContext context, EObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EOperation returns EOperation
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         ordered=EBoolean? 
	 *         unique=EBoolean? 
	 *         lowerBound=EInt? 
	 *         upperBound=EInt? 
	 *         eType=[EClassifier|EString]? 
	 *         (eExceptions+=[EClassifier|EString] eExceptions+=[EClassifier|EString]*)? 
	 *         (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)? 
	 *         eGenericType=EGenericType? 
	 *         (eTypeParameters+=ETypeParameter eTypeParameters+=ETypeParameter*)? 
	 *         (eParameters+=EParameter eParameters+=EParameter*)? 
	 *         (eGenericExceptions+=EGenericType eGenericExceptions+=EGenericType*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_EOperation(ISerializationContext context, EOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EParameter returns EParameter
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         ordered=EBoolean? 
	 *         unique=EBoolean? 
	 *         lowerBound=EInt? 
	 *         upperBound=EInt? 
	 *         eType=[EClassifier|EString]? 
	 *         (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)? 
	 *         eGenericType=EGenericType?
	 *     )
	 * </pre>
	 */
	protected void sequence_EParameter(ISerializationContext context, EParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EStructuralFeature returns EReference
	 *     EReference returns EReference
	 *
	 * Constraint:
	 *     (
	 *         volatile?='volatile'? 
	 *         transient?='transient'? 
	 *         unsettable?='unsettable'? 
	 *         derived?='derived'? 
	 *         containment?='containment'? 
	 *         name=EString 
	 *         ordered=EBoolean? 
	 *         unique=EBoolean? 
	 *         lowerBound=EInt? 
	 *         upperBound=EInt? 
	 *         changeable=EBoolean? 
	 *         defaultValueLiteral=EString? 
	 *         resolveProxies=EBoolean? 
	 *         eType=[EClassifier|EString]? 
	 *         eOpposite=[EReference|EString]? 
	 *         (eKeys+=[EAttribute|EString] eKeys+=[EAttribute|EString]*)? 
	 *         (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)? 
	 *         eGenericType=EGenericType?
	 *     )
	 * </pre>
	 */
	protected void sequence_EReference(ISerializationContext context, EReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EStringToStringMapEntry returns EStringToStringMapEntry
	 *
	 * Constraint:
	 *     (key=EString? value=EString?)
	 * </pre>
	 */
	protected void sequence_EStringToStringMapEntry(ISerializationContext context, Map.Entry semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ETypeParameter returns ETypeParameter
	 *
	 * Constraint:
	 *     (name=EString (eAnnotations+=EAnnotation eAnnotations+=EAnnotation*)? (eBounds+=EGenericType eBounds+=EGenericType*)?)
	 * </pre>
	 */
	protected void sequence_ETypeParameter(ISerializationContext context, ETypeParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ComplexTimefunction returns TimeFunction
	 *     ExeTimeFunction returns TimeFunction
	 *
	 * Constraint:
	 *     (function=TimeFunctions par1=EDouble par2=EDouble?)
	 * </pre>
	 */
	protected void sequence_ExeTimeFunction(ISerializationContext context, TimeFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Execution returns Execution
	 *
	 * Constraint:
	 *     elements+=Elements+
	 * </pre>
	 */
	protected void sequence_Execution(ISerializationContext context, Execution semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns ExternalDependency
	 *     ExternalDependency returns ExternalDependency
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         synchronous=EBoolean? 
	 *         numberOfServers=EInt? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution?
	 *     )
	 * </pre>
	 */
	protected void sequence_ExternalDependency(ISerializationContext context, ExternalDependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Elements returns FlowFinal
	 *     ConnectableNode returns FlowFinal
	 *     FlowFinal returns FlowFinal
	 *
	 * Constraint:
	 *     source=[ConnectableNode|ID]
	 * </pre>
	 */
	protected void sequence_FlowFinal(ISerializationContext context, FlowFinal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExecutionPackage.Literals.FLOW_FINAL__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExecutionPackage.Literals.FLOW_FINAL__SOURCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFlowFinalAccess().getSourceConnectableNodeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ExecutionPackage.Literals.FLOW_FINAL__SOURCE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Elements returns Flow
	 *     Flow returns Flow
	 *
	 * Constraint:
	 *     (source=[ConnectableNode|ID] target=[ConnectableNode|ID] timeFunction=ComplexTimefunction?)
	 * </pre>
	 */
	protected void sequence_Flow(ISerializationContext context, Flow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Elements returns ForkNode
	 *     ConnectableNode returns ForkNode
	 *     ForkNode returns ForkNode
	 *
	 * Constraint:
	 *     (source=[ConnectableNode|ID] targets+=[ConnectableNode|ID] targets+=[ConnectableNode|ID]* timeFunction=ComplexTimefunction?)
	 * </pre>
	 */
	protected void sequence_ForkNode(ISerializationContext context, ForkNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Function
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         synchronous=EBoolean? 
	 *         numberOfServers=EInt? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution?
	 *     )
	 * </pre>
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Heuristic
	 *     Heuristic returns Heuristic
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         synchronous=EBoolean? 
	 *         numberOfServers=EInt? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution?
	 *     )
	 * </pre>
	 */
	protected void sequence_Heuristic(ISerializationContext context, Heuristic semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Actor returns Human
	 *     Human_Impl returns Human
	 *
	 * Constraint:
	 *     (name=EString documentation=EString?)
	 * </pre>
	 */
	protected void sequence_Human_Impl(ISerializationContext context, Human semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     referencedModel=[Model|STRING]
	 * </pre>
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, abcdPackage.Literals.IMPORT__REFERENCED_MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, abcdPackage.Literals.IMPORT__REFERENCED_MODEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getReferencedModelModelSTRINGTerminalRuleCall_2_0_1(), semanticObject.eGet(abcdPackage.Literals.IMPORT__REFERENCED_MODEL, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataNode returns InputPin
	 *     Pin returns InputPin
	 *     InputPin returns InputPin
	 *
	 * Constraint:
	 *     (
	 *         optional?='optional'? 
	 *         stream?='stream'? 
	 *         type=[TypeSpecification|ID]? 
	 *         name=EString 
	 *         documentation=EString? 
	 *         collect=EInt? 
	 *         raceSemantic=RaceSemantic? 
	 *         queueType=QueueType? 
	 *         (parameters+=Parameter parameters+=Parameter*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_InputPin(ISerializationContext context, InputPin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeSpecification returns IntegerAttribute
	 *     IntegerAttribute returns IntegerAttribute
	 *
	 * Constraint:
	 *     (array?='['? name=ID defaultValue=EInt?)
	 * </pre>
	 */
	protected void sequence_IntegerAttribute(ISerializationContext context, IntegerAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralBoolean
	 *     LiteralBoolean returns LiteralBoolean
	 *     Primary returns LiteralBoolean
	 *
	 * Constraint:
	 *     value?='true'?
	 * </pre>
	 */
	protected void sequence_LiteralBoolean(ISerializationContext context, LiteralBoolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralByte
	 *     LiteralByte returns LiteralByte
	 *     Primary returns LiteralByte
	 *
	 * Constraint:
	 *     (name=EString value=Byte?)
	 * </pre>
	 */
	protected void sequence_LiteralByte(ISerializationContext context, LiteralByte semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralCharacter
	 *     LiteralCharacter returns LiteralCharacter
	 *     Primary returns LiteralCharacter
	 *
	 * Constraint:
	 *     (name=EString value=Character?)
	 * </pre>
	 */
	protected void sequence_LiteralCharacter(ISerializationContext context, LiteralCharacter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralDate
	 *     LiteralDate returns LiteralDate
	 *     Primary returns LiteralDate
	 *
	 * Constraint:
	 *     (name=EString value=Date?)
	 * </pre>
	 */
	protected void sequence_LiteralDate(ISerializationContext context, LiteralDate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralDouble
	 *     LiteralDouble returns LiteralDouble
	 *     Primary returns LiteralDouble
	 *
	 * Constraint:
	 *     {LiteralDouble}
	 * </pre>
	 */
	protected void sequence_LiteralDouble(ISerializationContext context, LiteralDouble semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralFloat
	 *     LiteralFloat returns LiteralFloat
	 *     Primary returns LiteralFloat
	 *
	 * Constraint:
	 *     {LiteralFloat}
	 * </pre>
	 */
	protected void sequence_LiteralFloat(ISerializationContext context, LiteralFloat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralInteger
	 *     Primary returns LiteralInteger
	 *     LiteralInteger returns LiteralInteger
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_LiteralInteger(ISerializationContext context, LiteralInteger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CorePackage.Literals.LITERAL_INTEGER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CorePackage.Literals.LITERAL_INTEGER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralIntegerAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralLong
	 *     LiteralLong returns LiteralLong
	 *     Primary returns LiteralLong
	 *
	 * Constraint:
	 *     (name=EString value=Long?)
	 * </pre>
	 */
	protected void sequence_LiteralLong(ISerializationContext context, LiteralLong semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralNull
	 *     LiteralNull returns LiteralNull
	 *     Primary returns LiteralNull
	 *
	 * Constraint:
	 *     {LiteralNull}
	 * </pre>
	 */
	protected void sequence_LiteralNull(ISerializationContext context, LiteralNull semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralShort
	 *     LiteralShort returns LiteralShort
	 *     Primary returns LiteralShort
	 *
	 * Constraint:
	 *     (name=EString value=Short?)
	 * </pre>
	 */
	protected void sequence_LiteralShort(ISerializationContext context, LiteralShort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueSpecification returns LiteralString
	 *     LiteralString returns LiteralString
	 *     Primary returns LiteralString
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_LiteralString(ISerializationContext context, LiteralString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CorePackage.Literals.LITERAL_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CorePackage.Literals.LITERAL_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralStringAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Connector returns LogicalConnector
	 *     LogicalConnector returns LogicalConnector
	 *
	 * Constraint:
	 *     (name=EString source=[Pin|EString] target=[Pin|EString] documentation=EString? (parameters+=Parameter parameters+=Parameter*)?)
	 * </pre>
	 */
	protected void sequence_LogicalConnector(ISerializationContext context, LogicalConnector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns MachineLearningComponent
	 *     MachineLearningComponent returns MachineLearningComponent
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         synchronous=EBoolean? 
	 *         numberOfServers=EInt? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution?
	 *     )
	 * </pre>
	 */
	protected void sequence_MachineLearningComponent(ISerializationContext context, MachineLearningComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Elements returns MergeNode
	 *     ConnectableNode returns MergeNode
	 *     MergeNode returns MergeNode
	 *
	 * Constraint:
	 *     (sources+=[ConnectableNode|ID] sources+=[ConnectableNode|ID]* timeFunction=ComplexTimefunction? target=[ConnectableNode|ID])
	 * </pre>
	 */
	protected void sequence_MergeNode(ISerializationContext context, MergeNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         (imports+=Import imports+=Import*)? 
	 *         personsPicturesPath=EString? 
	 *         (types+=TypeSpecification types+=TypeSpecification*)? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (packages+=Package packages+=Package*)? 
	 *         (actors+=Actor actors+=Actor*)? 
	 *         (variants+=Variant variants+=Variant*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Multiplication returns Multiplication
	 *     Multiplication.Multiplication_2_0 returns Multiplication
	 *
	 * Constraint:
	 *     (left=Primary | (left=Multiplication_Multiplication_2_0 (multiplication?='*' | division?='/') right=Primary))
	 * </pre>
	 */
	protected void sequence_Multiplication(ISerializationContext context, Multiplication semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataNode returns OutputPin
	 *     Pin returns OutputPin
	 *     OutputPin returns OutputPin
	 *     AssignableElement returns OutputPin
	 *
	 * Constraint:
	 *     (
	 *         stream?='stream'? 
	 *         type=[TypeSpecification|ID]? 
	 *         name=EString 
	 *         documentation=EString? 
	 *         amplify=EInt? 
	 *         outputUncertainty=EDouble? 
	 *         raceSemantic=RaceSemantic? 
	 *         (parameters+=Parameter parameters+=Parameter*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_OutputPin(ISerializationContext context, OutputPin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Package returns Package
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiesComponent=[Component|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (connectors+=Connector connectors+=Connector*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         (sectors+=Sector sectors+=Sector*)? 
	 *         (packages+=Package packages+=Package*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Package(ISerializationContext context, abcd.xy.metamodel.abcd.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterDefinition returns ParameterDefinition
	 *
	 * Constraint:
	 *     (name=EString unit=UnitOfMeasurement? (parameters+=[Parameter|EString] parameters+=[Parameter|EString]*)? defaultValue=ValueSpecification?)
	 * </pre>
	 */
	protected void sequence_ParameterDefinition(ISerializationContext context, ParameterDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (
	 *         parameterDefinition=[ParameterDefinition|EString] 
	 *         (appliesOnlyOnVariants+=[Variant|EString] appliesOnlyOnVariants+=[Variant|EString]*)? 
	 *         (doesNotApplyOnVariants+=[Variant|EString] doesNotApplyOnVariants+=[Variant|EString]*)? 
	 *         initialValue=ValueSpecification? 
	 *         currentValue=ValueSpecification?
	 *     )
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, abcd.xy.metamodel.abcd.analysis.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Actor returns Person
	 *     Person returns Person
	 *
	 * Constraint:
	 *     ((name=EString | (surname=EString name=EString)) documentation=EString? department=EString? pictureFileName=EString?)
	 * </pre>
	 */
	protected void sequence_Person(ISerializationContext context, Person semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns PhysicalComponent
	 *     PhysicalComponent_Impl returns PhysicalComponent
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution?
	 *     )
	 * </pre>
	 */
	protected void sequence_PhysicalComponent_Impl(ISerializationContext context, PhysicalComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Connector returns PhysicalConnector
	 *     PhysicalConnector returns PhysicalConnector
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         source=[Pin|EString] 
	 *         target=[Pin|EString] 
	 *         documentation=EString? 
	 *         minSpeed=Connectionspeed? 
	 *         maxSpeed=Connectionspeed? 
	 *         (parameters+=Parameter parameters+=Parameter*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_PhysicalConnector(ISerializationContext context, PhysicalConnector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Actor returns Robot
	 *     Robot returns Robot
	 *
	 * Constraint:
	 *     (name=EString documentation=EString?)
	 * </pre>
	 */
	protected void sequence_Robot(ISerializationContext context, Robot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Sector returns Sector
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         (sectors+=Sector sectors+=Sector*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Sector(ISerializationContext context, Sector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Sensor
	 *     Sensor returns Sensor
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution?
	 *     )
	 * </pre>
	 */
	protected void sequence_Sensor(ISerializationContext context, Sensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns SoftwareComponent
	 *     SoftwareComponent_Impl returns SoftwareComponent
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         documentation=EString? 
	 *         firingStrategy=ComponentFiringStrategy? 
	 *         timeFunction=ComplexTimefunction? 
	 *         (pins+=Pin pins+=Pin*)? 
	 *         synchronous=EBoolean? 
	 *         numberOfServers=EInt? 
	 *         mainResponsible=[Person|EString]? 
	 *         specifiedInPackage=[Package|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (components+=Component components+=Component*)? 
	 *         (datastores+=DataStore datastores+=DataStore*)? 
	 *         execution=Execution?
	 *     )
	 * </pre>
	 */
	protected void sequence_SoftwareComponent_Impl(ISerializationContext context, SoftwareComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeSpecification returns StringAttribute
	 *     StringAttribute returns StringAttribute
	 *
	 * Constraint:
	 *     (array?='['? name=ID defaultValue=EString?)
	 * </pre>
	 */
	protected void sequence_StringAttribute(ISerializationContext context, StringAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeSpecification returns TypeSpecification
	 *
	 * Constraint:
	 *     (abstract?='abstract'? name=ID superType=[TypeSpecification|ID]? (attributes+=AttributeSpecification attributes+=AttributeSpecification*)?)
	 * </pre>
	 */
	protected void sequence_TypeSpecification(ISerializationContext context, TypeSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary returns VariableRef
	 *     VariableRef returns VariableRef
	 *
	 * Constraint:
	 *     variable=[Variable|ID]
	 * </pre>
	 */
	protected void sequence_VariableRef(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExecutionPackage.Literals.VARIABLE_REF__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExecutionPackage.Literals.VARIABLE_REF__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableRefAccess().getVariableVariableIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ExecutionPackage.Literals.VARIABLE_REF__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Elements returns Variable
	 *     AssignableElement returns Variable
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (name=ID expression=Expression?)
	 * </pre>
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Variant returns Variant
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_Variant(ISerializationContext context, Variant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CorePackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CorePackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariantAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
