/**
 * generated by Xtext 2.26.0
 */
package e4sm.de.metamodel.xtext.tests;

import com.google.inject.Inject;
import e4sm.de.metamodel.e4sm.Component;
import e4sm.de.metamodel.e4sm.Model;
import e4sm.de.metamodel.e4sm.execution.Element;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.testing.InjectWith;
import org.eclipse.xtext.testing.extensions.InjectionExtension;
import org.eclipse.xtext.testing.util.ParseHelper;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function0;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

@ExtendWith(InjectionExtension.class)
@InjectWith(E4smInjectorProvider.class)
@SuppressWarnings("all")
public class E4smParsingTest {
  @Inject
  private ParseHelper<Model> parseHelper;
  
  private static final String toBeParsed = new Function0<String>() {
    @Override
    public String apply() {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("model test {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("picturesPath : \"a/b/c\"");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("package P {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("component C {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("in stream in1,");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("out out1,");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("in pinName {}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("runs {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("var testLiteral = 3;");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("const testSum = 3 + 3;");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("const testMultiplication = 6 * 7;");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("in1 -> out1 takes Exp(1.0);");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("},");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("softwareComponent S {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("in softwIn,");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("out softwOut");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("},");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("mlComponent ML {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("in mlIn,");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("out mlOut");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("},");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("physicalComponent PC {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("in pcIn,");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("out pcOut");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("},");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("function F {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("in fIn,");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("out fOut");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("},");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("actuator A {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("in AIn");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("//sensor S {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("//\tout Sout");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("//\ttimeFunction EXP(1.0)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("//}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      return _builder.toString();
    }
  }.apply();
  
  @Test
  public void loadModel() {
    try {
      final Model result = this.parseHelper.parse(E4smParsingTest.toBeParsed);
      Assertions.assertNotNull(result);
      Assertions.assertEquals(result.getName(), "test");
      Assertions.assertEquals(result.getPersonsPicturesPath(), "a/b/c");
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder.append(_join);
      Assertions.assertTrue(_isEmpty, _builder.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void parsePackage() {
    try {
      final Model result = this.parseHelper.parse(E4smParsingTest.toBeParsed);
      Assertions.assertEquals(result.getPackages().get(0).getName(), "P");
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder.append(_join);
      Assertions.assertTrue(_isEmpty, _builder.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void parseComponent() {
    try {
      final Model result = this.parseHelper.parse(E4smParsingTest.toBeParsed);
      Assertions.assertEquals(result.getPackages().get(0).getComponents().get(0).getName(), "C");
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder.append(_join);
      Assertions.assertTrue(_isEmpty, _builder.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void parseComponentPins() {
    try {
      final Model result = this.parseHelper.parse(E4smParsingTest.toBeParsed);
      final Component component = result.getPackages().get(0).getComponents().get(0);
      Assertions.assertTrue(component.getPins().get(0).isStream());
      Assertions.assertFalse(component.getPins().get(1).isStream());
      Assertions.assertEquals(component.getPins().get(0).getName(), "in1");
      Assertions.assertEquals(component.getPins().get(1).getName(), "out1");
      Assertions.assertEquals(component.getPins().get(2).getName(), "pinName");
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder.append(_join);
      Assertions.assertTrue(_isEmpty, _builder.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void parseComponentExecution() {
    try {
      final Model result = this.parseHelper.parse(E4smParsingTest.toBeParsed);
      final EList<Element> el = result.getPackages().get(0).getComponents().get(0).getExecution().getElements();
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder.append(_join);
      Assertions.assertTrue(_isEmpty, _builder.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
